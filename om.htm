<html>
<head>
    <meta charset="utf-8" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="description" content="" />
    <meta name="author" content="Maxim Sokhatsky" />
    <title>OM</title>
    <link rel="stylesheet" href="5HT.css" />
</head>
<body>
<div class=menu>
<a href="index.html">groupoid.co</a><font color=silver>/om</font>
</div>
<hr>
<div class=app>

<div class=block style="width:230px;height:550px;">
        <img src="Om.svg" height=200>
</div>

<div class=block style="width:700px;">
<center><h1>Om Assembler</h1>
        <h5>CoC Intermediate Language<br> for typechecking and normalization</h5></center>

<h1>Definition</h1>

<center><h2><a name="nat">Calculus of Constructions</a></h2></center>

<p>The <span class=sel>Om</span> language is a dependently typed lambda calculus, an extension of
Barendregt' and Coquand Calculus of Constructions with predicative
hierarchy of indexed universes. There is no fixpoint axiom needed
for the definition of infinity term dependance.</p>

<center><h2><a name="axioms">Axioms and Inference Rules</a></h2></center>

<p>All terms respect ranking <span class=sel>A</span> inside sequence of universes <span class=sel>S</span> and
complexity of the dependent term is equal maximum complexity of term and its dependency <span class=sel>R</span>.
The type system is completely described by the following PTS notation (due to Barendregt):</p>

<pre style="width:500px;">

    S = *{n}, n : nat
    A = *{i} : *{i+1}
    R = *{i} -> *{j} : *{max i j}

</pre>

<center><h2><a name="syntax">Syntax</a></h2></center>

The untyped lambda language is simplest language used in Om to generate backend programs.
This subset of Om is used as output of type erasure.

<pre  style="width:550px;">

    I ::= #identifier

    T ::= I | ( T ) | T T | λ I → T

</pre>

<p>The terms of Om consist of NN-indexed stars, variables, applications,
   lambda-abstractions and universal quantifications (Pi-types).
   This language is called Calculus of Construction and exists in various syntaxes.
   Om supports Morte's CoC syntax.</p>

<pre  style="width:600px;">

   <> ::= #option

    I ::= #identifier

    U ::= * < #number >

    O ::= U | I | ( O ) | O O | λ ( I : O ) → O
                      | O → O | ∀ ( I : O ) → O

</pre>

<center><h2><a name="ast">AST</a></h2></center>

<pre  style="width:500px;">

  data om: * :=
       (star: nat → om)
       (var: name → om)
       (app: om → om → om)
       (lambda: name → om → om → om)
       (arrow: om → om → om)
       (pi: name → om → om → om)

</pre>

<center><h2><a name="ast">Parser</a></h2></center>

<p>Om implements custom 2N linear bi-directional parser using pattern-matching
   for rules definition.</p>

<p>In a given grammar applications <span class=sel>O&nbsp;O</span> associate to the
left and function arrows like <span class=sel>O&nbsp;→&nbsp;O</span>,
<span class=sel>∀&nbsp;(&nbsp;N&nbsp;:</span> and <span class=sel>λ&nbsp;(&nbsp;N&nbsp;:</span> associate right.
They are being collapsed during forward and backward pass respectively.
Expressions <span class=sel>∀&nbsp;(&nbsp;N&nbsp;:</span> и <span class=sel>λ&nbsp;(&nbsp;N&nbsp;:</span>
are being replaced during forward pass to <span class=sel>$&nbsp;N</span>,
partial function constructor defined only with name. When forward pass meets
closing paren <span class=sel>)</span> it turns to backward pass until reach
<span class=sel>$&nbsp;N</span>, then collapse to <span class=sel>:&nbsp;N I</span> &mdash;
partial defined function constructor with name and type of argument, but not
with type of result. During backward pass all arrows are being collapsed with
<span class=sel>:&nbsp;N I</span> into <span class=sel>∀&nbsp;(N:&nbsp;I)&nbsp;→&nbsp;O</span>
or <span class=sel>λ&nbsp;(N:&nbsp;I)&nbsp;→&nbsp;O</span> &mdash; fully defined named function contructor.
To determine when to collapse <span class=sel>:&nbsp;N I</span> when nested parens
are given using <span class=sel>(&nbsp;O&nbsp;)</span> construction
in the type of function argument, like in
<span class=sel>λ&nbsp;(N:&nbsp;((a)&nbsp;b)&nbsp;l&nbsp;→&nbsp;o)&nbsp;→&nbsp;o</span>
parser should count parens starting from nearest left function definition.</p>

<h3>Forward</h2>

<p>LL(1-4)</p>

<pre style="background:white;font-size:12pt;">

  []                        : rewind
  [close]                   : rewind, continue
  [f open (var l) colon]    : [($ (f l))]
  [remote x l]      [(c y)] : [App (c y) (parse l)]
  [remove x l]              : [parse l]
  [($ x)]                   : [(n x)]
  [(n x)]           [(c y)] : [App (c y) (n x)]
  [x]                       : [x]

</pre>

<h3>Rewind</h2>

<p>LL(2-3)</p>

<pre style="background:white;font-size:12pt;">

  [((: _) _)]                    : return
  [($ n)] [(b y)]                : rewind [((: n) (b y))]
  [(b y) ($ n)]     < Balanced > : rewind [((: n) (b y))]
  [(b y) ($ n)]                  : return [((: n) (b y))]
  [(c x) open ((: n) i)]         : return [(c x) ((: n) i)]
  [(c x) open ($ n)]             : return [(c x) ($ n)]
  [(c x) open open]              : return [(c x) open]
  [(c x) open (b y)]             : return [App (b y) (c x)]
  [(c x) open]                   : return [(c x)]
  [arrow ((: (n v)) i)] [(c x)]  : rewind [n v i (c x)], n = {Lambda,Pi}
  [(c x) arrow ((: (n v)) i]     : rewind [n v i (c x)], n = {Lambda,Pi}
  [arrow (b y)]     [(c x)]      : rewind [Arrow (b y) (c x)]
  [(c x) arrow (b y)]            : rewind [Arrow (b y) (c x)]
  []                             : return

</pre>

<center><h2><a name="typechecker">Typechecker</a></h2></center>

<h3>Type</h2>

<pre style="background:white;font-size:12pt;">

  (Star n)         D : Star n + 1

  (Var n)          D : isVar n D,
                       nth (i + 1) (all n D)

  (Arrow i o)      D : Star max (star (type i D))
                                (star (type o D))

  (Pi n 0 i o)     D : Star max (star (type i D))
                                (star (type o [(n norm i)|D]))

  (Lambda n 0 i o) D : star (type i D),
                       ni = norm i,
                       Pi n 0 ni (type O [(n ni)|D])

  (App f a)        D : t = type f D,
                       isFun t,
                       Pi n 0 i o = t,
                       eq i (type a D),
                       norm (subst o n a)

</pre>

<h1>Passes</h1>

<center><h2><a name="normal">Normalized</a></h2></center>

Terms in CoC language.

<pre  style="width:750px;">

 $ om show List/Cons

   λ (A: *)
 → λ (Head: A)
 → λ (Tail:
     ∀ (List: *)
   → ∀ (Cons:
       ∀ (Head: A)
     → ∀ (Tail: List)
     → List)
   → ∀ (Nil: List)
   → List)
 → λ (List: *)
 → λ (Cons:
     ∀ (Head: A)
   → ∀ (Tail: List)
   → List)
 → λ (Nil: List)
 → Cons Head (Tail List Cons Nil)

 {{"λ",{'A',0}},
  {{star,1},
   {{"λ",{'Head',0}},
    {{var,{'A',0}},
     {{"λ",{'Tail',0}},
      {{{"∀",{'List',0}},
        {{star,1},
         {{"∀",{'Cons',0}},
          {{{"∀",{'Head',0}},
            {{var,{'A',0}},
             {{"∀",{'Tail',0}},
              {{var,{'List',0}},{var,{'List',0}}}}}},
           {{"∀",{'Nil',0}},
            {{var,{'List',0}},{var,{'List',0}}}}}}}},
       {{"λ",{'List',0}},
        {{star,1},
         {{"λ",{'Cons',0}},
          {{{"∀",{'Head',0}},
            {{var,{'A',0}},
             {{"∀",{'Tail',0}},
              {{var,{'List',0}},{var,{'List',0}}}}}},
           {{"λ",{'Nil',0}},
            {{var,{'List',0}},
             {app,{{app,{{var,{'Cons',0}},
                         {var,{'Head',0}}}},
                   {app,{{app,{{app,{{var,{'Tail',0}},
                                     {var,{'List',0}}}},
                               {var,{'Cons',0}}}},
                         {var,{'Nil',0}}}}}}}}}}}}}}}}}}

</pre>

<center><h2><a name="erased">Erased</a></h2></center>

Terms in untyped lambda pure language.

<pre  style="width:500px;">

  $ om print fst erase a "#List/Cons"
  ( λ Head
  → ( λ Tail
  → ( λ Cons
  → ( λ Nil
  → ((Cons Head) ((Tail Cons) Nil))))))
  ok

</pre>

<center><h2><a name="extract">Extract</a></h2></center>

Erlang extracted code. For other targets you may want to read <a href="extract.htm">Code&nbsp;Extract</a> notes.

<pre  style="width:800px;">

  'Cons'() -> fun (Head) -> fun (Tail) -> fun (Cons) -> fun (Nil) ->
              ((Cons(Head))((Tail(Cons))(Nil))) end end end end.

</pre>

<h1>Resources</h1>

<p>01 &nbsp;<a href="https://gitter.im/groupoid/om/archives/">OM ARCHIVES</a></p>
<p>02 &nbsp;<a href="https://github.com/groupoid/om">GIT SOURCES</a></p>


<br>

<center style="margin-top: 120px;margin-bottom:60px;"><img style="margin-bottom:-20px;" src="Stamp.svg" width=50>2016 &copy; Groupoid Infinity, Inc.</center>

</div>

</body>
</html>
