<html>
<head>
    <meta charset="utf-8" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="description" content="" />
    <meta name="author" content="Maxim Sokhatsky" />
    <title>OM</title>
    <link rel="stylesheet" href="5HT.css" />
</head>
<body>
<div class=menu>
<a href="index.html">groupoid.co</a><font color=silver>/om</font>
</div>
<hr>
<div class=app>

<div class=block style="width:230px;height:550px;">
        <img src="Om.svg" height=200>
</div>

<div class=block style="width:700px;">
<center><h1>Om Assembler</h1>
        <h5>CoC Intermediate Language<br> for typechecking and normalization</h5></center>

<h1>Definition</h1>

<center><h2><a name="nat">Calculus of Constructions</a></h2></center>

<p>The <span class=sel>Om</span> language is a dependently typed lambda calculus, an extension of
Barendregt' and Coquand Calculus of Constructions with predicative
hierarchy of indexed universes. There is no fixpoint axiom needed
for the definition of infinity term dependance.</p>

<center><h2><a name="axioms">Axioms and Inference Rules</a></h2></center>

<p>All terms respect ranking <span class=sel>A</span> inside sequence of universes <span class=sel>S</span> and
complexity of the dependent term is equal maximum complexity of term and its dependency <span class=sel>R</span>.
The type system is completely described by the following PTS notation (due to Barendregt):</p>

<pre style="width:500px;">

    S = *{n}, n : nat
    A = *{i} : *{i+1}
    R = *{i} -> *{j} : *{max i j}

</pre>

<center><h2><a name="syntax">Syntax</a></h2></center>

The untyped lambda language for performance on virual machines.

<pre  style="width:550px;">

    I ::= #identifier

    T ::= I | ( T ) | T T | λ I → T

</pre>

<p>The terms of Om consist of NN-indexed stars, variables, applications,
   lambda-abstractions and universal quantifications (Pi-types).
   This language is called a Calculus of Construction and exists in various syntaxes.
   Om supports Morte's CoC syntax.</p>

<pre  style="width:600px;">

   <> ::= #option

    I ::= #identifier

    U ::= * < #number >

    O ::= U | I | ( O ) | O O | λ ( I : O ) → O
                      | O → O | ∀ ( I : O ) → O

</pre>

<center><h2><a name="ast">AST</a></h2></center>

<pre  style="width:500px;">

  data om: * :=
       (star: nat → om)
       (var: name → om)
       (app: om → om → om)
       (lambda: name → om → om → om)
       (arrow: om → om → om)
       (pi: name → om → om → om)

</pre>

<center><h2><a name="ast">Parser</a></h2></center>

<p>Om implements two-pass accumulating stream parser for the CoC programs.
   Here is pattern-matching specification of rules per match
   of incoming stream and accumulator:</p>

<pre style="background:white;font-size:12pt;">

  parser:

  []             : rewind
  [close]        : rewind, continue
  [remote x l]   : [om.term l]
  [star i]       : [star i]
  [c x]   [:a y] : [((c x) (:a y)]
  [c x]    [b y] : [app (b y) (c x)]
  [star]         : [star 1]
  [var l,colon]  : [(:a l)]
  [var l]        : [var l]
  [x]            : [x]

  rewind:

  []             [arrow (app x y) z]            : error1
  [pi]           [arrow (_ (app (:a m) c) x) y] : error2
  [lambda]       [arrow (_ (app (:a m) c) x) y] : error3
  [pi]           [arrow (app (:a m) x) y]       : rewind [pi m x y]
  [lambda]       [arrow (app (:a m) x) y]       : rewind [lambda m x y]
  [open,pi]      [arrow (_ (app (:a m) c) x) y] : return [pi m x y]
  [open,lambda]  [arrow (_ (app (:a m) c) x) y] : return [lambda m x y]
  [open,(:a z)]  [_ (app x y) y]                : error4
  [open,c x]     [b y]                          : return [app (c x) (b y)]
  [open]                                        : return
  [c x]          [b y]                          : rewind [app (c x) (b y)]
  [c x]                                         : rewind [c x]
  [arrow,((f n) (i o))]      [y]                : rewind [((f n) (arrow i o))]
  [arrow,arrow (app x y) i]  [y]                : error5
  [arrow,x]      [y]                            : rewind [arrow x y]
  []                                            : return

</pre>

<h1>Passes</h1>

<center><h2><a name="normal">Normalized</a></h2></center>

Terms in CoC language.

<pre  style="width:500px;">

   λ (A: *)
 → λ (Head: A)
 → λ (Tail:
     ∀ (List: *)
   → ∀ (Cons:
       ∀ (Head: A)
     → ∀ (Tail: List)
     → List)
   → ∀ (Nil: List)
   → List)
 → λ (List: *)
 → λ (Cons:
     ∀ (Head: A)
   → ∀ (Tail: List)
   → List)
 → λ (Nil: List)
 → Cons Head (Tail List Cons Nil)

</pre>

<center><h2><a name="erased">Erased</a></h2></center>

Terms in untyped lambda pure language.

<pre  style="width:500px;">

   λ Head
 → λ Tail
 → λ Cons
 → λ Nil
 → Cons Head (Tail Cons Nil)

</pre>

<center><h2><a name="extract">Extract</a></h2></center>

Erlang extracted code. For other targets you may want to read <a href="extract.htm">Code&nbsp;Extract</a> notes.

<pre  style="width:800px;">

  'Cons'() -> fun (Head) -> fun (Tail) -> fun (Cons) -> fun (Nil) ->
              ((Cons(Head))((Tail(Cons))(Nil))) end end end end.

</pre>

<h1>Resources</h1>

<p>01 &nbsp;<a href="https://gitter.im/groupoid/om/archives/">OM ARCHIVES</a></p>
<p>02 &nbsp;<a href="https://github.com/groupoid/om">GIT SOURCES</a></p>


<br>

<center style="margin-top: 120px;margin-bottom:60px;"><img style="margin-bottom:-20px;" src="Stamp.svg" width=50>2016 &copy; Groupoid Infinity, Inc.</center>

</div>

</body>
</html>
