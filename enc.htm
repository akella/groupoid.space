<html>
<head>
    <meta charset="utf-8" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="description" content="" />
    <meta name="author" content="Maxim Sokhatsky" />
    <title>ENCODING</title>
    <!--script type="text/javascript" src="http://cdn.mathjax.org/mathjax/2.2-latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script-->
    <link rel="stylesheet" href="5HT.css" />
</head>
<body>

<script> MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']], processEscapes: true } });
                                  TeX: { extensions: ["AMSmath.js", "AMSsymbols.js"] }; </script>

<div class=menu>
<a href="index.html">groupoid.co</a><font color=silver>/encoding</font>
</div>
<hr>

<div class=app>
<div class=block style="width:700px;margin-left:150px;">

<center><h1>Lambek Encoding</h1>
        <h5>Categorical Semantics of Inductive Encodings</h5><br></center>

<div align=right>Paul Lyutko, Maxim Sokhatsky<br>
                  DATE: 1 MAY 2016</div>

<center><h2><a name="nat">Initial Object</a></h2></center>

<pre style="width:600px;">

    let I = data List: (A:*) -> * :=
                 (nil: () -> List A)
                 (cons: A -> List A -> List A)

</pre>

<center><h2><a name="nat">Representing Functor F</a></h2></center>

<pre style="width:400px;">

           F<sub>A</sub> = 1 + A * X

</pre>

<center><h2><a name="nat">Construct corresponding F-Algebra</a></h2></center>

<pre style="width:600px;">

    record ListAlg: (A:*) -> * :=
           (X: *)
           (nil: () -> X)
           (cons: A -> X -> X)

</pre>

<center><h2><a name="axioms">Introduce List Morphisms</a></h2></center>

<pre style="width:740px;background-color:white;">

  infix '=' := Setoid.Ob.Equ

  record ListMor: (A: *) -> (x1 x2: ListAlg A) -> * :=
         (map: x1.X -> x2.X)
         (okNil: Eq (map x1.nil) x2.nil)
         (okCons: ‚àÄ (a: A) -> ‚àÄ (x: x1)
               -> map x1.cons a x = x2.cons a (map x))

</pre>

<center><h2><a name="axioms">Introduce connected points of List type</a></h2></center>

<pre style="width:740px;background-color:white;">

  record ListPoint: (A: *) -> * :=
         (point:  ‚àÄ (x: ListAlg A) -> x.X)
         (pointOk:  ‚àÄ (x1 x2: ListAlg A)
                 -> ‚àÄ (m: ListMor A x1 x2)
                 -> Setoid.Ob.Equ (map m point x1) (point x2))

</pre>

<center><h2><a name="axioms">Theorem</a></h2></center>

<pre style="width:740px;background-color:white;">

  def ‚ì™ := Cat.mk ()
  def ‚ë† := Cat.mk ùüô<sub>ListAlg</sub>

  record Theorem := *
         (intro: colim ‚ì™ = lim ‚ë†)

</pre>

$$
\require{AMSmath}
\require{AMSsymbols}
\def\mapright#1{\xrightarrow{{#1}}}
\def\mapdown#1{\Big\downarrow\rlap{\raise2pt{\scriptstyle{#1}}}}
\def\mapdiagl#1{\vcenter{\searrow}\rlap{\raise2pt{\scriptstyle{#1}}}}
\def\mapdiagr#1{\vcenter{\swarrow}\rlap{\raise2pt{\scriptstyle{#1}}}}
$$


<center>

$$U = ListAlg\\$$

$$U\ I = lim\ U\\$$

  $\begin{array}{c}lim\ U\\\mapdown{\pi_i}\\X_i\end{array}
   \Longrightarrow \begin{array}{c}F\ lim\ U\\\mapdown{F\ \pi_i}\\F\ X_i\end{array}
   \Longrightarrow lim\ \begin{array}{c}F\ lim\ U\\\mapdown{F \pi_i}\\F\ X_i\end{array}$
</center>

<center><h2><a name="axioms">Precise Encoding</a></h2></center>

<p>Our encoding allows you to precise control the type of encoded parameter.
   There is only three cases and three equations: 1) for unit; 2) particular functorial
   type over a parameter type and 3) recursive embedding such as in Cons constructor.</p>

   <p><b>q</b> &mdash; is a limit in <b>Dialg P</b> category. The constructor body is calculated
      with <b>q</b> applied to forgetful functor <b>U</b>.</p>

$$
q_{P,D,G} : End\ P\ (G'(-),G'(-)) \rightarrow P\ (Lim\ G',Lim\ G') \\
P : Set¬∞ \times Set \rightarrow Set \\
U : Dialg\ P \rightarrow Set \\
G : D \rightarrow Dialg\ P \\
G' = UG : D \rightarrow Set \\
U (Lim\ G) = Lim\ G'
$$

<center><h3><a name="axioms">Unit Parameters</a></h3></center>

<p>Like for Bool or Nil constructors encoding.</p>

$$
P_0(A,B) =  B \\
q_0\ e : Lim\ G' \\
q_0\ e = e
$$

<center><h3><a name="axioms">Fixed Type Parameters</a></h3></center>

<p>Like for Cons first parameter.</p>

$$
P_1(A,B) = X \rightarrow P(A,B) \\
q_1\ e : X \rightarrow P ( Lim\ G',  Lim\ G' ) \\
q_1\ e\ x\ A = e\ A\ x

$$

<center><h3><a name="axioms">Recursive Parameters</a></h3></center>

<p>Like for Cons second parameter. This case is a key in encoding recursive
   data types such as <b>Lists</b> and recursive record types such as <b>Streams</b>.</p>

$$
P_2(A,B) = A \rightarrow P(A,B) \\
q_2\ e : Lim\ G' \rightarrow P ( Lim\ G',  Lim\ G' ) \\
q_2\ e\ I\ A = e\ A\ (I\ A)

$$

<center><h2><a name="axioms">Identity Functor Encoding</a></h2></center>

<p>As known as predicative encoding</a>

$$
\begin{array}{ccccccc}
      A &           & \mapright{f} &           & B & \mapright{f} & Set \\[3pt]
        & \mapdiagl{a}  & \varphi      & \mapdiagr{b}  &   & \searrow     & \mapdown{\mathbf{1}} \\
        &           & Set          &           &   &              & Set
\end{array}
$$

$\varphi : a \rightarrow b$

<center><h2><a name="axioms">Identity Functor Limit Encoding</a></h2></center>

<p>As known as impredicative encoding</a>

$$
\begin{array}{ccccccc}
      A &           & \mapright{f} &           & B & \mapright{f} & Set \\[3pt]
        & \mapdiagl{a}  & \varphi      & \mapdiagr{b}  &   & \searrow     & \mapdown{\mathbf{1}} \\
        &           & Set          &           &   &              & Set
\end{array}
$$

$lim\ \varphi : lim\ a \rightarrow lim\ b$

<h1>Resources</h1>

<p>01 &nbsp;<a href="https://gitter.im/groupoid/om/archives/">OM ARCHIVES</a></p>
<p>02 &nbsp;<a href="https://github.com/groupoid/om">GIT SOURCES</a></p>


<br>

<center style="margin-top: 120px;margin-bottom:60px;"><img style="margin-bottom:-20px;" src="Stamp.svg" width=50>2016 &copy; Groupoid Infinity, Inc.</center>

</div>
</div>

</body>
</html>
