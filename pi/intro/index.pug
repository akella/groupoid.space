extends ../../layout.pug

block title
    script(src='//cdnjs.cloudflare.com/ajax/libs/mathjax/2.6.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML')
    script.
       MathJax.Hub.Config({
          tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']], processEscapes: true },
          jax: ["input/TeX", "input/MathML", "input/AsciiMath", "output/CommonHTML", "output/NativeMML"],
          TeX: { extensions: ["AMSmath.js", "AMSsymbols.js", "autoload-all.js"] },
          extensions: ["tex2jax.js", "asciimath2jax.js", "mml2jax.js", "MathMenu.js", "MathZoom.js"],
          "HTML-CSS": { imageFont: null },
       });
    title Process Calculus

block content
    +header('../../groupoid.svg', 'Process Calculus', 'Formal Model of Business Process Engine')
    article.main
        .om
            section
                h1 Intro
            aside Максим Сохацький, Київ<br>
                24-05-2018
            p.
            section
                p.
                    Process Calculus defines formal business process engine that coule
                    be mapped onto Synrc BPE Erlang/OTP application or OCaml Lwt library
                    with Coq.io front-end. Here is given top level model in cubical syntax.

                h1 Process Modality

                p.
                    <b>Definition</b> (Storage). The secure storage based on verified
                    cryptography. NOTE: For simplicity let it be a compatible list.

                code.
                    storage: U -> U = list

                p.
                    <b>Definition</b> (Process). The type formation rule of the process
                    is a $\Sigma$ telescope that contains: i) protocol type; ii) state type;
                    iii) in-memory current state of process in the form of cartesian product
                    of protocol and state which is called signature of the process; iv) monoidal
                    action on signature; v) persistent storage for process trace.

                code.
                    process : U
                            = (protocol state: U)
                            * (current: prod protocol state)
                            * (act: id (prod protocol state))
                            * (storage (prod protocol state))

                p.
                    <b>Definition</b> (Spawn). The sole introduction rule, process constructor
                    is a tuple with filled process type information.

                code.
                    spawn (protocol state: U) (init: prod protocol state)
                          (action: id (prod protocol state)) : process
                        = (protocol,state,init,action,nil)

                p.
                    <b>Definition</b> (Accessors). Process type defines following
                    accessors (projections, this eliminators) to its structure:
                    i) protocol type; ii) state type; iii) signature of the
                    process; iv) current state of the process; v) action
                    projection; vi) trace projection.

                code.
                        protocol  (p: process): U = p.1
                        state     (p: process): U = p.2.1
                        signature (p: process): U = prod p.1 p.2.1
                        current   (p: process):          signature p  = p.2.2.1
                        action    (p: process):      id (signature p) = p.2.2.2.1
                        trace     (p: process): storage (signature p) = p.2.2.2.2

                p.
                    NOTE: the are two kinds of approaches to process design:
                    1) Semigroup: $P \times S \rightarrow S$;
                    and 2) Monoidal: $P \times S \rightarrow P \times S$,
                    where P is protocol and S is state of the process.

                p.
                    <b>Definition</b> (Execute). The Execute function is an
                    eliminator of process stream performing adding single entry
                    to the secured storage of the process.

                code.
                        execute (p: process) (message: protocol p) : process
                              = let step: signature p = (action p) (message, (current p).2)
                                 in (protocol p, state p, step, action p, cons step (trace p))

