extends ../layout.pug

block title
    title Om

block content
    +header('/groupoid.svg', 'Trusted λ&nbsp;Assembler', 'CoC Intermediate Language<br>for typechecking and normalization')
    article.main
        .om
            section
                h1 Definition

                h2#nat Calculus of Constructions
                p.
                    The <mark>Om</mark> language is a dependently typed lambda calculus, an extension of Barendregt' and Coquand Calculus of Constructions with the predicative hierarchy of indexed universes. There is no fixpoint axiom needed for the definition of infinity term dependance.

                h2#axioms Axioms and Inference Rules
                p.
                    All terms obey the <mark>A</mark> ranking inside the sequence of <mark>S</mark> universes,
                    and the complexity <mark>R</mark> of the dependent term is equal to a maximum of
                    the term's complexity and its dependency.
                    The type system is completely described by  the following PTS notation (due to Barendregt):
                code.
                    S = *{n}, n : nat
                    A = *{i} : *{i+1}
                    R = *{i} -> *{j} : *{max i j}

                h2#syntax Syntax
                p.
                    The untyped lambda language is the simplest language used in Om to generate backend programs. This subset of Om is used as the output of type erasure.
                code.
                    I ::= #identifier
                    T ::= I | ( T ) | T T | λ I → T
                p.
                    The terms of Om consist of NN-indexed stars, variables, applications, lambda-abstractions and universal quantifications (Pi-types). This language is called Calculus of Construction and exists in various syntaxes. Om supports Morte's CoC syntax.
                code.
                    <> ::= #option
                    I  ::= #identifier
                    U  ::= * < #number >
                    O  ::= U | I | ( O ) | O O | λ ( I : O ) → O
                                    | O → O | ∀ ( I : O ) → O

                h2#ast AST
                code.
                    data om: * :=
                         (star: nat → om)
                         (var: name → om)
                         (app: om → om → om)
                         (lambda: name → om → om → om)
                         (arrow: om → om → om)
                         (pi: name → om → om → om)

                h2#parser Parser
                p.
                    Om implements custom 2N linear bi-directional parser using
                    pattern-matching for rules definition.
                p.
                    In a given grammar applications <mark>O O</mark> associate to the left and function arrows like <mark>O → O</mark>, <mark>∀ ( N :</mark> and <mark>λ ( N :</mark> associate to the right. They are being collapsed during forward and backward pass respectively. Expressions <mark>∀ ( N :</mark> и <mark>λ ( N :</mark> are being replaced during forward pass to <mark>$ N</mark>, partial function constructor defined only with name. When forward pass meets closing paren <mark>)</mark> it turns to backward pass until reach <mark>$ N</mark>, then collapse to <mark>: N I</mark> &mdash; partial defined function constructor with name and type of argument, but not with type of result. During backward pass all arrows are being collapsed with <mark>: N I</mark> into <mark>∀ (N: I) → O</mark> or <mark>λ (N: I) → O</mark> &mdash; fully defined named function contructor. To determine when to collapse <mark>: N I</mark> when nested parens are given using <mark>( O )</mark> construction in the type of function argument, like in <mark>λ (N: ((a) b) l → o) → o</mark> parser should count parens starting from nearest left function definition.

                h3 Forward
                p LL(1-4)
                code.
                    []                        : rewind
                    [close]                   : rewind, continue
                    [f open (var l) colon]    : [($ (f l))]
                    [remote x l]      [(c y)] : [App (c y) (parse l)]
                    [remove x l]              : [parse l]
                    [($ x)]                   : [(n x)]
                    [(n x)]           [(c y)] : [App (c y) (n x)]
                    [x]                       : [x]

                h3 Rewind
                p LL(2-3)
                code.
                    [((: _) _)]                    : return
                    [($ n)] [(b y)]                : rewind [((: n) (b y))]
                    [(b y) ($ n)]     < Balanced > : rewind [((: n) (b y))]
                    [(b y) ($ n)]                  : return [((: n) (b y))]
                    [(c x) open ((: n) i)]         : return [(c x) ((: n) i)]
                    [(c x) open ($ n)]             : return [(c x) ($ n)]
                    [(c x) open open]              : return [(c x) open]
                    [(c x) open (b y)]             : return [App (b y) (c x)]
                    [(c x) open]                   : return [(c x)]
                    [arrow ((: (n v)) i)] [(c x)]  : rewind [n v i (c x)], n = {Lambda,Pi}
                    [(c x) arrow ((: (n v)) i]     : rewind [n v i (c x)], n = {Lambda,Pi}
                    [arrow (b y)]     [(c x)]      : rewind [Arrow (b y) (c x)]
                    [(c x) arrow (b y)]            : rewind [Arrow (b y) (c x)]
                    []                             : return

                h2#typechecker Typechecker
                h3 Type
                code.
                    (Star n)         D : Star n + 1

                    (Var n)          D : isVar n D,
                                         nth (i + 1) (all n D)

                    (Arrow i o)      D : Star max (star (type i D))
                                                  (star (type o D))

                    (Pi n 0 i o)     D : Star max (star (type i D))
                                                  (star (type o [(n norm i)|D]))

                    (Lambda n 0 i o) D : star (type i D),
                                         ni = norm i,
                                         Pi n 0 ni (type O [(n ni)|D])

                    (App f a)        D : t = type f D,
                                         isFun t,
                                         Pi n 0 i o = t,
                                         eq i (type a D),
                                         norm (subst o n a)
            section
                h1 Passes

                h2#normal Normalized
                p Terms in CoC language.
                code.
                    $ om show List/Cons

                    λ (A: *)
                    → λ (Head: A)
                    → λ (Tail:
                        ∀ (List: *)
                    → ∀ (Cons:
                        ∀ (Head: A)
                        → ∀ (Tail: List)
                        → List)
                    → ∀ (Nil: List)
                    → List)
                    → λ (List: *)
                    → λ (Cons:
                        ∀ (Head: A)
                    → ∀ (Tail: List)
                    → List)
                    → λ (Nil: List)
                    → Cons Head (Tail List Cons Nil)

                    {{"λ",{'A',0}},
                    {{star,1},
                    {{"λ",{'Head',0}},
                    {{var,{'A',0}},
                        {{"λ",{'Tail',0}},
                        {{{"∀",{'List',0}},
                        {{star,1},
                            {{"∀",{'Cons',0}},
                            {{{"∀",{'Head',0}},
                            {{var,{'A',0}},
                                {{"∀",{'Tail',0}},
                                {{var,{'List',0}},{var,{'List',0}}}}}},
                            {{"∀",{'Nil',0}},
                            {{var,{'List',0}},{var,{'List',0}}}}}}}},
                        {{"λ",{'List',0}},
                        {{star,1},
                            {{"λ",{'Cons',0}},
                            {{{"∀",{'Head',0}},
                            {{var,{'A',0}},
                                {{"∀",{'Tail',0}},
                                {{var,{'List',0}},{var,{'List',0}}}}}},
                            {{"λ",{'Nil',0}},
                            {{var,{'List',0}},
                                {app,{{app,{{var,{'Cons',0}},
                                            {var,{'Head',0}}}},
                                    {app,{{app,{{app,{{var,{'Tail',0}},
                                                        {var,{'List',0}}}},
                                                {var,{'Cons',0}}}},
                                            {var,{'Nil',0}}}}}}}}}}}}}}}}}}


                h2#erased Erased
                p Terms in untyped lambda pure language.
                code.
                    $ om print fst erase a "#List/Cons"
                    ( λ Head
                    → ( λ Tail
                    → ( λ Cons
                    → ( λ Nil
                    → ((Cons Head) ((Tail Cons) Nil))))))
                    ok

                h2#extract Extract
                p.
                    Erlang extracted code. For other targets you may want to read
                    <a href='/extract'> Code Extract</a> notes.
                code.
                    'Cons'() -> fun (Head) -> fun (Tail) -> fun (Cons) -> fun (Nil) ->
                        ((Cons(Head))((Tail(Cons))(Nil))) end end end end.

        include ../resourses.pug