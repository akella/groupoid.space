<!DOCTYPE html><html><head><meta charset="utf-8"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="author" content="Maxim Sokhatsky"><link rel="stylesheet" href="/main.css"><title>INTRO</title></head><body class="content"><header class="header"><a href="/"><img class="header__logo" src="/groupoid.svg"/></a><div class="header__titles"><h1 class="header__title">Intro</h1><h4 class="header__subtitle">Canvas of Computable Functions Theories and Provers</h4></div></header><article class="main"><aside>Maxim Sokhatsky<time>15 FEB</time></aside><div class="intro"><h2 id="fpga">LISP</h2><p>Untyped lambda calculus was discovered as an inner language of the space
at the origin (Curry, Church, 1932). This language was manifested as LISP (McCarthy, 1958)
that was built upon: cons, nil, eq, atom, car, cdr, lambda, apply and id.
It was parts of inductive types lately known as inductive type constructors.
Still, untyped lambda calculus is used as an extraction target for many
provers (Idris, F*), and also manifests in different domain languages (JavaScript, Erlang).
</p><h2 id="fpga">ML/LCF</h2><p>Further teardown of inner space language was ML language, founded merely on algebraic
datatypes and algebra on higher terms rather than categorical semantic. Lately, it
was fixed with categorical methods in CPL (Hagino, 1987) and Charity (Cockett, 1992).
Milner, assisted by Morris and Newey designed Meta Language for the purpose of building LCF
in early 70-s. LCF was a predecessor family of automated math provers: HOL88,
HOL90, HOL98 and HOL/Isabelle which is now built using Poly/ML.
</p><h2 id="other">Fully Automated Provers</h2><p>In that period during 80-90s other automated math systems were appeared:
AUTOMATH (de Bruijn, 1967), Mizar (Trybulec, 1989), PVS (Owre, Rushby, Shankar, 1995),
ACL2 (Boyer, Kaufmann, Moore, 1996) and Otter (McCune, 1996).
</p><h2 id="mltt">MLTT</h2><p>Contemporary provers (built upon consistent Martin-Löf Type Theory, 1972)
like Agda, Coq, Lean, F*, Idris are based on Barendregt
and Coquand' CoC with different flavors of infinity universe hierarchies
and Calculus of Inductive Constructions. Some of them are automated and some
are trying to be and general purpose programming languages with proving facilities.
</p><h2 id="fpga">OM/EXE</h2><p><mark>No Fixpoint and Induction in Core.</mark> We came up with pure CoC core having predicative
and impredicative universe hierarchies and macro extensions. Other MLTT cores have additional
axioms like Fixpoint and Induction (and even more) — something we strive to escape
because it leads to the complex core. No, we don't have Fixpoint, and yes,
we implemented Induction principle in pure CoC.</p><p><mark>Extensible Language Design.</mark> Encoding of inductive types is based on categorical semantic
of compilation to CoC. All other syntax constructions are inductive definitions, plugged
into the stream parser. AST of the CoC language is also defined in terms of inductive
constructions and thus allowed in the macros. The language of polynomial functors (data
and record) and core language of the process calculus (spawn, receive and send) is just
macrosystem over CoC language, its syntax extensions.</p><p><mark>Changable Encodings.</mark> In pure CoC we have only arrows, so all inductive type encodings
would be Church-encoding variations. Most extended nowadays is Church-Boehm-Berrarducci
the encoding which dedicated to inductive types. Another well known are Scott (laziness),
Parigot (laziness and constant-time iterators) and CPS (continuations) encodings.</p><p><mark>Proved Categorical Semantic.</mark> There was modeled a math model (using higher-order
categorical logic) of encoding, which calculates (co)limits in a category of (co)algebras
built with given set of (de)constructors. We call such encoding in honor of Lambek lemma
that leads us to the equality of (co)initial object and (co)limit in the categories
of (co)algebras. Such encoding works with dependent types and its consistency is proved
in Lean model.</p></div></article><footer class="footer"><img class="footer__logo" src="/stamp.svg"><span class="footer__copy">2016&mdash;2017 &copy; Groupoid Infinity, Inc.</span></footer></body></html>