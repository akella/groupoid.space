% copyright (c) 2015 Synrc Research Center

\documentclass[11pt,oneside]{article}

\input{synrc.tex}
\begin{document}

\thispagestyle{empty}
\begin{center}

\begin{minipage}[t]{2cm}
    \includegraphics[scale=0.4]{img/S}
\end{minipage}
\begin{minipage}[t]{12cm}
    \begin{flushright}
        \textsc{{\Large {\bf {\color{Blue}syn}{\color{OrangeRed}rc} research center s.r.o.}}}\\
        \textsc{Roháčova 141/18, Praha 3 13000, Czech Republic}\\
    \end{flushright}
\end{minipage}

\vspace{3cm}

    \vspace{3cm}   {\Large \bf Системна інженерія та верифікація\\ \vspace{0.2cm} уніфікованого обчислювального середовища}\par
    \vspace{1cm}   {\Large \bf System Engineering and Verification\\ \vspace{0.2cm} of Unified Execution Environment}\par
    \vspace{3cm}   {\Large Павло Маслянко, Київський Політехнічний Інститут\par}
    \vspace{0.3cm} {\Large Максим Сохацький, Synrc Research Center\par}
    \vspace{4cm}   {\Large Листопад 2015}

\end{center}

\newpage
\vspace{2cm}
\tableofcontents
\newpage
\section{Вступ}

\vspace{1cm}

%\vspace{0.5cm}

\subsection{Системна інженерія}

   Протягом історії обчислювальної техніки було створено різні класи та способи обчислень,
   різні тоеорії та підходи до програмування таких систем, різні класи систем програмування.
   Зараз уже стало зрозумілим, що інженіринг систем які не піддаються до верифікації
   формальними методами не може бути застосований у галузях де вимоги до якості
   особливо підвищені, як то космонавтика, енергетика та телекомунікації.

\subsection{Уніфіковані обчислювальні середовища}

   Називатимемо програмні комплекси та системи, які розповсюджуються на всі прошарки моделі OSI вище фізичного,
   уніфікованими середовищами. Перелічуючи проекти, які вплинули на хід історії
   обчислювальної техніки, серед такого уніфікованих замкнених систем, можна згадати Smalltalk-80,
   створений в Xerox Parc Аланом Кеєм, якого можна назвати творцем
   об'єктно-орієнтованого підходу, за що він був удостоєний премії Тюрінга.
   Віртуальні машини середовища Smalltalk представляють відносно ізольовану
   по відношенню до операційної системи систему типів разом з моделью акторів, що дозволяє
   самостійно розподіляти час обчислювального середевища. Стан таких віртуальних машин апаратно незалежний
   та може бути перенесений на віртуальні машини які працюють на процесорах інших архітектур.
   Інший класс систем які були представлені у той час -- це Lisp машини. Вони теж були
   здатні зберігати стан своєї віртуальної машини яка,
   як і усе середовище була, написана на мові Lisp. Серед експериментальних та науково-дослідних
   уніфікованих систем можна відзначити Singularity від Microsoft Research, яка давно є постачальником
   високоякісних теоретико-практичних інструментів по верифікації програмного забезпечення.
   Сучасні уніфіковані системи, які здатні виконуватися без операційної системи,
   існують на трьох платформах (на OCaml це MirageOS, на Haskell це HaLVM,
   для Erlang це віртуальна машина LING, яка створена в Україні). В даній роботі дається обгрунтуванню вибору
   віртуальної машини Erlang та її операційної семантки у якості основи для обчислювального
   середовища та його сервісів.

   \paragraph{}
   При застосуванні формальних методів доведення коректності, велике значення має повнота і замкненість системи,
   адже недоведені або неверифіковані частини можуть вплинути на детермінованість — а отже якість — системи.
   Тому має велике значення забезпечення виконання системи якогомога ближче до апаратного забезпечення.
   Основні напрямки побудови замкнених середовищ на функціональних мовах програмування
   існують для мов Erlang, Haskell та OCaml.

\newpage
\subsection{Верифікація програмного забезпечення}

   \paragraph{}
   За багато років кількість теорій, які використовуються для побудови програмного забезпечення значно розширилися:
   починаючи з теорії компіляції сучаних функціональних мов, та систем програмування на основі теорії типів,
   включаючи сучасні моделі обчислень, які побудовані на основі лямбда числення та числення процесів, закінчуючи віртуальними
   машинами, які працююсь у семантиці захищених, простих за структурою процесів, час яких розподіляється
   у прозорий та ефективний спосіб.

   \paragraph{}
   Розглядаючи системи, які піддаються формальній верифікації, кажуть про
   сертифіковане або верифіковане програмне забезпечення. Серед логічних систем, які
   застосовувалися для цього можна відзначити клас темпоральних логік для доведення
   цілісності розподілених у просторі та часі систем (приклали таких систем: NuPRL від університету Корнела в Нью-Йорку;
   TLA+ фреймворк Леслі Лампорта з Microsoft Research, за який він отримав премію Тюрінга), а також системи з залежними
   типами (теорія типів Мартіна Льофа) побудовані на основі числення індуктивних конструкцій. Приклади таких систем:

   Coq побудована на мові OCaml від національного науково-дослідного інституту Франції INRIA;
   Agda побудовані на мові Haskell від шведського інституту технологій Чалмерс;
   Lean побудована на мові C++ від Microsoft Research та Універсистету Каргені-Мелона;
   Idris подудована на мові Haskell Едвіна Бреді з шотландського Університету ім. св. Андрія;
   F* -- окремий проект Microsoft Research.

\subsection{Компактні адаптивні протоколи}

   Зараз на планеті налічується близько 50 міліардів пристроїв які повинні обслуговуватися
   масштабованими ефективними серверними комплексами які гарантовано не виконують
   додаткових та непотрібних обчислень. Це потребує повного перепроектування усіх протоколів
   які виникають між компонентами та підсистемами. Ця робота також представляє
   уніфікований та простий стек протоколів розроблюваного обчислювального середовища.

   \begin{center}
   \vspace{0.5cm}
   \includegraphics[scale=0.15]{img/protocols}
   \end{center}

\newpage

\subsection{Завдання дослідження}
\vspace{0.5cm}

   Тактична мета даної роботи -- це реалізація усіх верхніх компонентів OSI на базі
   формальної теорії та мови із залежними типами. Побудова зручної сучасної гнучкої верифікованої теорії
   з компактною системою типів є основним завданням даної роботи. Будемо орієнтуватися
   на мінімально можливу систему типів та набір функцій які забезпечать успішне промислове
   впровадження кінцевого продукту з компактною, проте достатньо потужною системою типів.

   \paragraph{}
   В першу чергу мова йде про три найголовніші
   сервіси: збереження інформації, система управління процесами та мультиплікатор протоколів,
   який у даній системі відіграє роль сервера додатків. Успішна реалізація цих трьох систем
   дасть нам змогу будувати більш складні та масштабовані транзакційні системи та сервіси на базі
   створеної формальної теорії, а також прокладе шлях подальшому розвитку даного
   теоретико-практичного комплексу.

   \begin{center}
   \vspace{0.5cm}
   \includegraphics[scale=0.15]{img/exe-res}
   \end{center}

   \paragraph{\bf Апаратура}
   Що стосується апаратної частини моделі OSI, то тут ми будемо вважати умовно,
   що апаратне забезпечення і так проходить усі належні види моделювань, такі як
   розрахункові, імітаційні, та інші. Крім того, як ми знаємо, верифіковані моделі уже застосовуються
   для розробки мікропроцесорів.

   \paragraph{\bf Віртуальна машина}
   Верифікована система типів середнього рівня моделі OSI --- віртуальної машини
   є предметом майбутніх досліджень. Адам Чіпала \cite{chipvm} показав як можна
   верифікувати виконання команд віртуальної машини та компіляцію цих команд в байт-код.

   \paragraph{\bf Сервіси}
   Верифікована система типів верхнього рівня моделі OSI --- це центральний фокус даної роботи.
   Ми розглянемо декілька основних сервісів, які забезпечують персистентність, виконання процесів,
   та мультиплікацію протоколів.

   \newpage

\subsubsection{Зберігання обчислень}
   \paragraph{}
   У цій роботі ми будемо верифікувати системні бібліотеки для
   майбутньої верифікованої віртуальної машини. Зокрема значна увага буде приділятися
   послідовностям. Система персистентного зберігання послідовностей є ядром нашого
   обчислювального середовища. Властивості цієї підсистеми є основоположними
   для перевірки констистентності операційних логів розподілених баз даних.


\subsubsection{Виконання процесів}
   \paragraph{}
   Тут ми дамо формальне визначення та верифікуємо
   типи системи управління структурованими процесами або FSM автоматами.
   Бізнес-процеси це зручний та ефективний спосіб упорядкування та формалізації
   потоків даних. Ми зосередимося на найкомпактніших алгебрах.

\subsubsection{Комутація протоколів}
   \paragraph{}
   Ця частина дасть відповідь на питання структурування
   протоколів та визначення універсального мультиплікатора. Буде описаний повний стек
   протоколів для IoT та WebSocket додатків.

\subsubsection{Розподілені у просторі та часі системи}

   \paragraph{}
   Сучасний розвиток техніки та теоретична межа швидкості обробки процесорів вивів на передній план алгоритми та структури
   даних які ефективно використовують розподілені у просторі та часі ресурси, як то об’єми пам’яті та обчислювальні потужності.
   Принципи та підходи паралельного та узгодженого програмування дають змогу масштабувати системи та обчислення, однак
   анонсують нові теорії для забезпечення коректності в умовах підвищеної складності алгоритмів у розподілених системах,
   такі як алгоритми забезпечення консистентності та транзакційності у розподілених системах PAXOS\cite{lampax} та CR\cite{renesse1}.
   Сучасні обчислювальні середовища повинні ефективно управляти великими масивами
   даних та необмежено масштабуватися. Розподілена архітектура сервера транзакцій,
   що працює поверх формально верифікованого сховища даних, буде представлена
   окремою роботою. Даний прототип існує у вигляді координатора транзакцій, який працює
   за алгоритмом ланцюгової реплікації і використовує семантику сховища, яке
   у формальному вигляді представлене у цій роботі.

\subsubsection{Різні аксіоматичні рівні}

   Важливо додати, що з формальної точки зору потрібно, щоби на границях
   трьох системних рівнів формальні типи дотичних логічних теорій співпадали.
   Для доведення коректності формалізованої віртуальної машини достатньо
   визначити систему типів командної мови процесора та типи їх операндів. А для
   доведення коректності верхнього рівня достатньо аксіоматизувати дотичну
   формальну теорію віртуальної машини. Тому в даній роботі буде представлена
   така публічна система типів віртуальної машини, що одразу відкриє дорогу
   для деталізації і подальшої теоретичної розробки формальної теорії для віртуальної машини.

\newpage

\subsection{Структура роботи}
\vspace{0.5cm}

   \paragraph{}
   Покладаючись на аналіз рішень в області уніфікованих середовищ та
   набір математичного і лінгвістичного забезпечення у якості формальних методів,
   ми будемо формувати формальну теорію та бібліотеку типів для формальної
   реалізації ключових підсистем.

   \paragraph{}
   Усі існуючі уніфіковані системи, оскільки є замкненими, пропонують
   повністю свій інтерфейс взаємодії, свою операційну семантику та свою систему типів.
   У цьому смислі наша система не є винятком і пропонує повний стек
   програмного забезпечення, ключові частини якого ми намагатимемося формально
   описати.

   \paragraph{}
   На основі створеної базової теорії та її бібліотеки типів ми створимо
   формальними методами доказову базу для кожного компонента обчислювального
   середовища, який включений в дану роботу: {\bf зберігання обчислень},
   {\bf виконання процесів}, {\bf мультиплікатор протоколів}.

   \paragraph{}
   Далі кожна така верифікована система буде транслюватися в цільову мову
   віртуальної машини обчислювального середовища, яка у загальному випадку
   може відрізнятися від вибраної нами Erlang.

   \paragraph{}
   Особливість цієї уніфікованої системи в повному та тотальному перегляді
   усіх існуючих рішень, включно з базовими протоколами інтернету типу HTTP.
   Так, наприклад, для сервера додатків у якості транспортного протоколу
   використовується бінарний WebSocket протокол. Усі протоколи формулюються
   у вигляді алгебр над станами процесів.

\subsubsection{Уніфіковані обчислювальні середовища}

   \paragraph{}
   Об’єктом дослідження є усі можливі моделі обчислювальних середовищ в основному придатних
   до верифікованого аналізу та обробки формальними методами. Ми вибрали середовище
   основане на віртуальних машинах зі своєю системою типів та байткодом, які уже
   використовуються у промисловій експлуатації в телекомунікаційній сфері та є лідерами
   у цій області -- це телекомунікаційна платформа від Ericsson -- Erlang/OTP. Ступінь проникнення
   цієї технологій у сучасних телекомунікаціях достатньо високий, особливо завдяки
   розвиненій підтримці ASN.1, SNMP, H.262, Radius та інших промислових стандартів
   у телекомунікаційній сфері. Перші успішні масштабні проекти на Erlang були створені ще у
   1986 році, а зараз Erlang демонструє успішність завдяки таким проектам як WhatsApp, який
   обслуговує 30 мільярдів повідомлень в день у порівнянні з SMS трафіком,
   який генерується щоденно у розмірі 20 мільярдів повідомлень.

\newpage

\subsubsection{Формальні методи}
\vspace{0.5cm}

   \paragraph{}
   Самі формальні методи теж є частиною об’єкта дослідження. Ми досліджуємо ті структури
   та алгоритми, які дадуть максимально ефективний спосіб кодування та виконання,
   забезпечуючи при цьому семантику, яка використовуються для машинного доведення
   коректності роботи алгоритмів та узгодженості міжпроцесних протоколів.
   Ми будемо розробляти робочу формальну теорію за допомогою індуктивних типів,
   переводячи результати на мову обчислювального середовища, Erlang.

   \paragraph{}
   Побудова розподілених та паралельних, тобто здатних виконуватися на багатьох машинах одночасно, та
   узгоджених, тобто не блокуючих, а значить лінеаризованих систем управліннями процесами є побічним
   результатом, який очікується від цієї роботи. Усі розподілені у просторі та часі
   протоколи ми будемо верифікувати використовуючи темпоральну логіку за допомогою системи TLA+.

   \paragraph{}
   Дамо чітке визначення формальним теоріям. Формальні теорії складаються з чотирьох компонентів:

\begin{itemize}
   \item двох алфавітів: терміналів та змінних;
   \item синтаксичних правил, або формул з вільними змінними;
   \item дедуктивних правил, або формул не залежних від змінних;
   \item набір закритих формул, які називаються аксіомами.
\end{itemize}

\paragraph{}

\subsubsection{Робоча теорія}

   \paragraph{}
   Вибравши конкретну систему автоматичного доведення теорем на основі теорії індуктивних типів,
   ми будуємо основні типи нашої теорії і визначаємо у нашій теорії сигнатури сервісів
   нашого обчислювального середовища. Досліджуємо побудовану систему типів на предмет
   відповідності до робочого прототипу та доводимо певні базові властивості, які є спільними для кожного із трьох
   сервісів включених до даної роботи. Виберемо для опрацювання робочої теорії
   систему автоматичного доведення теорем Lean від Microsoft Research в якості мови
   з залежними індуктивними типами.

\subsubsection{Формальна підсистема}

   \paragraph{}
   Кожну окрему підсистему ми будемо відокремлювати та визначати які теореми
   та які конструкції використовуються для побудови підсистеми формальним способом,
   використовуючи математичні конструкції робочої теорії. У нашому випадку є три
   типи моноїдальних систем, на основі яких ми можемо конструювати більш складні
   кінцеві системи-продукти для кінцевого користування та експлуатації.
   Для кожної підсистеми з цих трьох застосовується подібна методологія
   доведення коректності та трансляції математичної моделі в результуючу
   мову віртуальної машини.

\subsubsection{Результуюча мова}

   \paragraph{}
   Розроблені теореми та сигнатури
   формальної підсистеми потім компілюються або транслюються в результуючу мову віртуальної машини
   обчислювального середовища. В нашому випадку це мова Erlang та віртуальні
   машини BEAM від Ericsson, та LING від Cloudozer. Для цього нам в базовій теорії доведеться
   формально описати базові примітиви віртуальної машини Erlang та взяти їх
   у якості аксіом для нашої теорії.

\subsection{Додаткові та дотичні теорії}
\vspace{0.5cm}

   \subsubsection{Темпоральна логіка}
   Темпоральна логіка як індуктивна теорія верифікації розподілених алгоритмів
   застосовується до доведення коректності усіх нормалізованих підсистем. На основі
   теорії  Леслі Лампорта\cite{tla}, за яку він отримав премію Тюрінга.
   Елементи темпоральної логіки нам знадобляться для розробки теорій
   розподілених у просторі та часі алгоритмів.\\

   \subsubsection{Мережі Петрі}
   Мережі Петрі в даній роботі використовуються як прототип графічного
   лінгвістичного засобу структури категорій та системи типів. Оскільки
   такі графічні засоби як UML та різноманітні окремі технологічні
   стандарти як то BPMN більше допомагають ніж заважають, була розроблена
   також і графічна мова на базі графічної мови мереж Петрі, оскільки їх
   семантика ділить один простір з тематикою даної роботи. Ми візьмемо
   лінгвістичне забезпечення Мереж Петрі як прототип для нашої власної
   мови візуалізації структур обчислень.

   \subsubsection{Теорія масового обслуговування}
   Теорія масового обслуговування застосовується для побудови
   статистичних моделей та запобігання відмов. Перші роботи у цій області
   належать шведському математику Агнеру Крурупу Ерлангу, який займався
   дослідженнями трафіка у телефонних мережах. Модель масового обслуговування достатньо
   адекватно описує роботу віртуальної машини Erlang, де клієнти -- це процеси,
   які мають черги повідомлень, та здатні відправляти заявки на обслуговування
   у такі самі черги інших процесів. Ці заявки, чи повідомлення, складають певний
   протокол взаємодії у системі таких процесів. Тому тут теорія масового обслуговування
   застосовується для визначення пропускної здатності системи.

\newpage
\subsection{Основні теорії}
\vspace{0.3cm}

   \subsubsection{Теорія категорій}
   Теорія категорій широко застосовується як інструмент для математиків у тому числі і
   при аналізі програмного забезпечення. Теорію категорій можна вважати наближенням абстрактної алгебри функцій.
   Дамо конструктивне визначення категорії.
   Категорії (програми) визначаються переліком своїх об’єктів (типів) та своїх
   морфізмів (функцій), а також бінарною операцією композиції,
   що задовольняє закону асоціативності, та з тотожнім морфізмом (тотжньою функцією --- одиницею) який існує
   для кожного об’єкту (типу) категорії. Аксіоми формації об’єктів не
   приводяться та авто-постулуються в нижніх аксіомах. Аксіома формації
   морфізмів буде даватися як введеня експоненти після визначення декартового добутку.
   Поки що тут буде визначатися тільки композиція морфізмів. Об’єкти $A$ та $B$ морфізма $f: A \rightarrow B$
   називаються домен та кодомен відповідно.

   \paragraph{}
   Інтро аксіоми -- асоціативність композиції та права і ліва композиції одниці показують,
   що категорії є типизованими моноїдами, що складаються з морфізмів та операції композиції.
   Є різні мови, у тому числі і графічні, представлення категорної семантики, однак у цій роботі
   ми будемо використовувати теоретико-логічні формулювання.

\begingroup
\parbox[t][][l]{0.60\textwidth}{

\begin{prooftree}
\AxiomC{$\Gamma\ \vdash f: A \rightarrow B$ }
\AxiomC{$\Gamma\ \vdash g: B \rightarrow C$ }
\BinaryInfC{$\Gamma \vdash g \circ f : A \rightarrow C $}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Gamma \vdash f : B \rightarrow A$ }
\AxiomC{$\Gamma \vdash g : C \rightarrow B$ }
\AxiomC{$\Gamma \vdash h : D \rightarrow C$ }
\TrinaryInfC{$\Gamma \vdash (f \circ g) \circ h = f \circ (g \circ h) : D \rightarrow A $}
\end{prooftree}

}
\hspace{0.1cm}
\parbox[t][][r]{0.40\textwidth}{

\begin{prooftree}
\AxiomC{$$ }
\UnaryInfC{$\Gamma \vdash id_A : A \rightarrow A $}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Gamma\ \vdash f: A \rightarrow B$ }
\UnaryInfC{$\Gamma \vdash f \circ id_A = f : A \rightarrow B$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Gamma\ \vdash f: A \rightarrow B$ }
\UnaryInfC{$\Gamma \vdash id_B \circ f = f : A \rightarrow B $}
\end{prooftree}

}
\endgroup

\paragraph{}
Композиція показує можливість звязувати область значень попереднього обчислення (кодомен)
та область визначення наступного обчислення (домен). Композиція є фундаментальною властивістю морфізмів.

\paragraph{}
\begin{tabular}{lll}
$1.$ & $A: *$\\
$2.$ & $A: *\ ,\ B: * \implies f: A \rightarrow B$\\
$3.$ & $f: B \rightarrow C\ ,\ g: A \rightarrow B \implies f \circ g : A \rightarrow C$\\
$4.$ & $(f \circ g) \circ h = f \circ (g \circ h)$\\
$5.$ & $A \implies id : A \rightarrow A$\\
$6.$ & $f \circ id = f$\\
$7.$ & $id \circ f = f$\\
\end{tabular}

\newpage
\subsubsection*{Алгебраїчні типи даних}

Після операції композиції, як способу конструювання нових об’єктів
за допомогою морфізмів далі йде операція конструювання добутка двох об’єктів певної категорії,
разом з добутком морфізмів зі спільним доменом, необхідних для визначення декартового добутка $A \times B$.

\paragraph{}
Це є внутрішня мова декартової категорії, у якій для будь яких двох доменів існує їх декартова сума (кодобутку)
та декартовий добуток (косума, кортеж), за допомогою яких конструюються суми-протоколи та добутки-повідмоення,
а також існує $\bot$ тип-термінал, та $\top$ тип-котермінал. Термінальними типами зручно термінувати рекурсивні
типи даних, такі як списки. Ми будемо розглядати тільки категорії які маються добутки та суми.

\paragraph{}
Добуток має природні елімінатори $\pi$ зі спільним доменом, які є морфізмами-проекціями об’єктів добутка. Сума має оберненені
елімінатори $\sigma$ зі спільним кодоменом. Як видно добуток є дуальний до суми з точністю до направлення стрілок,
таким чином елімінатори $\pi$ та $\sigma$ є оберненими, тобто $\pi \circ \sigma = \sigma \circ \pi = id$.

\begingroup
\parbox[t][][l]{0.40\textwidth}{

\begin{prooftree}
\AxiomC{$\Gamma\ x: A \times B$ }
\UnaryInfC{$\Gamma \vdash \pi_1\ : A \times B \rightarrow A$;
           $\Gamma \vdash \pi_2\ : A \times B \rightarrow B$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Gamma \vdash\  a:A$ }
\AxiomC{$\Gamma \vdash\  b:B$ }
\BinaryInfC{$\Gamma \vdash\ (a,b) : A \times B$ }
\end{prooftree}

\begin{prooftree}
\AxiomC{}
\UnaryInfC{$\Gamma \vdash\ \bot$ }
\end{prooftree}

}
\hspace{0.1cm}
\parbox[t][][r]{0.60\textwidth}{

\begin{prooftree}
\AxiomC{}
\UnaryInfC{$\Gamma \vdash\ \top$ }
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Gamma \vdash\  a:A$ }
\AxiomC{$\Gamma \vdash\  b:B$ }
\BinaryInfC{$\Gamma\vdash a\ |\ b : A \otimes B$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Gamma\ x: A \otimes B$ }
\UnaryInfC{$\Gamma \vdash \sigma_1: A \rightarrow A \otimes B$;
           $\Gamma \vdash \sigma_2: B \rightarrow A \otimes B$}
\end{prooftree}

}
\endgroup

\paragraph{}
   Також додамо тут аксіому множення морфізмів, яка
   випливає з визначення добутка, яка необхідна для забезпечення аплікативного програмування.

\begin{prooftree}
\AxiomC{$\Gamma \vdash\ f:A \rightarrow B$ }
\AxiomC{$\Gamma \vdash\ g:A \rightarrow C$ }
\AxiomC{$\Gamma \vdash\ B \times C$ }
\TrinaryInfC{$\Gamma \vdash\ \langle f,g \rangle : A \rightarrow B \times C$ }
\end{prooftree}

\begin{center}
%$(f \circ g) \circ h = f \circ (g \circ h)$\\
%$f \circ id = f$\\
%$id \circ f = f$\\
$\pi_1 \circ \langle f, g \rangle = f$\\
$\pi_2 \circ \langle f, g \rangle = g$\\
$\langle f \circ \pi_1, f \circ \pi_2 \rangle = f$\\
$\langle f, g \rangle \circ h = \langle f \circ h, g \circ h \rangle$\\
$\langle \pi_1, \pi_2 \rangle = id$\\
\end{center}

\newpage
   \subsubsection{Лямбда числення}
   Будучи внутрішньою мовою декартово-замкненої категорії лямбда числення окрім змінних
   та констант у вигляді термів пропонує операції абстракції та аплікації, що визначає
   достатньо лаконічну та потужну структуру обчислень з функціями вищих порядків,
   та метатипизаціями, такими як System F, яка була запропонована
   вперше Робіном Мілнером в мові ML, та зараз присутня в більш складних,
   таких як System F$\omega$, системах Haskell та Scala.

   \paragraph{}
   Щоб пояснити функції з категоріальнї точки зору потрібно пояснити категоріальні
   експоненти $f : A^B$,  які є аналогами фукціональних просторів $f: A \rightarrow B$.
   Так як ми вже визначили добутки та термінали, то ми можемо визначити і експоненти,
   опускаючи усі категоріальні подробиці ми визначимо конструювання функції (операція абстракції),
   яка параметризується змінною $x$ у середовищі $\Gamma$; та її елімінатора -- операції аплікації
   функції до аргументу. Так визначаєьтся декартово-замкнена категорія.
   Визначається також рекурсивний механізм виклику функції
   з довільною кількістю аргументів.

\begingroup
\parbox[t][][l]{0.40\textwidth}{

\begin{prooftree}
\AxiomC{$\Gamma  x:A \vdash M : B$}
\UnaryInfC{$\Gamma \vdash \lambda\ x\ .\ M : A \rightarrow B$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Gamma\ f:A \rightarrow B$ }
\AxiomC{$\Gamma\ a:A$ }
\BinaryInfC{$\Gamma \vdash apply\ f\ a\ : (A \rightarrow B) \times A \rightarrow B$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Gamma \vdash f: A \times B \rightarrow C$ }
\UnaryInfC{$\Gamma \vdash curry\ f : A \rightarrow (B \rightarrow C)$}
\end{prooftree}

}
\hspace{0.1cm}
\parbox[t][][r]{0.60\textwidth}{


\begin{center}
$apply \circ \langle (curry\ f) \circ \pi_1 , \pi_2 \rangle = f$\\
$curry\ apply \circ \langle g \circ \pi_1, \pi_2 \rangle) = g$\\
$apply \circ \langle curry\ f, g \rangle = f \circ \langle id , g\rangle$\\
$(curry\ f) \circ g = curry\ (f \circ \langle g \circ \pi_1,\pi_2\rangle)$\\
$curry\ apply = id$\\
\end{center}

\begin{center}
Об’єкти : $\bot\ |\ \rightarrow\ |\ \times$\\
Морфізми : $id\ |\ f \circ g\ |\ \langle f, g \rangle\ |\ apply\ |\ \lambda\ |\ curry$
\end{center}

}
\endgroup


\newpage
   \subsubsection{Числення процесів}
   Теорія $\pi$-числення процесів Роберта Мілнера є основним формалізмом обчислювальної
   теорії розподілених систем та її імплементації. З часів виникнення CSP числення розробленого Хоаром,
   Мілнеру вдалося значно розширити та адаптувати теорію до сучасних
   телекомунікаційних вимог, як наприклад хендовери в мобільних мережах.
   Основні теорми в моделі $\pi$-числення стосуються непротиречивості та неблокованості
   у синхронному виконанні мобільних процесів. Так як сучасний Web можно розглядати
   як телекомунікаційну систему, тому у розробці додатків можна покладатися у тому
   числі і на такі моделі як $\pi$-числення.

  \subsubsection*{Процеси і протоколи}
  Також ми анонсуємо процес як фундаменльний тип даних, подібний до функції але який здатний
  тримати певний стан у вигляді типа коротежа та є морфізмом-одиницею типу свого стану.

\begin{prooftree}
\AxiomC{$\Gamma\ \vdash E, \Sigma, X$ }
\AxiomC{$\Gamma\ \vdash action : \Sigma \times X \rightarrow \Sigma \times X$ }
\BinaryInfC{$\Gamma \vdash {spawn}\ action : \pi_\Sigma $}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Gamma\ \vdash pid : \pi_\Sigma$ }
\AxiomC{$\Gamma\ \vdash msg : \Sigma$ }
\BinaryInfC{$\Gamma \vdash join\ msg\ pid : \Sigma \times \pi_\Sigma \xrightarrow{\bullet} \Sigma$;
            $\Gamma \vdash send\ msg\ pid : \Sigma \times \pi_\Sigma \rightarrow \Sigma$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Gamma\ \vdash L : A + B, R : X + Y$ }
\AxiomC{$\Gamma\ \vdash M : A \rightarrow X, N : B \rightarrow Y$ }
\BinaryInfC{$\Gamma \vdash receive\ L\ M\ N : L \xrightarrow{\bullet} R$}
\end{prooftree}

\paragraph{}


  \subsubsection*{Алгебра процесів}

  Алгебра процесів визначає базові операції мультиплексування двох чи декількох
  протоколів в рамках одного процесу (добуток), а також паралельного та повністю
  ізольованого запуску включно зі стеком та областю памяті (сума) на
  віртуальній машині.

\begin{center}
\begin{tabular}{lcl}
$\oplus$   &:& $\pi \parallel \pi$\\
$\otimes$  &:& $\pi \mid \pi$\\
\end{tabular}
\end{center}

  \subsubsection*{Типи процесів}

\begin{center}
\begin{tabular}{lll}
         $action$ &:& ${proc}_{Proc}\  (BPE\ |\ \Sigma) \times process \rightarrow process$ \\
          $event$ &:& ${proc}_{App}\   (N2O\ |\ \Sigma) \times cx \rightarrow cx$ \\
      $operation$ &:& ${proc}_{Store}\ (KVS\ |\ \Sigma) \times container \rightarrow container$ \\
\end{tabular}
\end{center}

\newpage
   \subsubsection{Інтуітіоністична теорія типів Мартіна Льофа}
   Системи з залежними типами як верифікаційні математичні формальні моделі
   для доведення корректності. Система $\Sigma$ та $\Pi$ типів, як кванторів
   існування та узагальнення. Системи Mizar, Coq, Agda, Idris, F*, Lean. Ми будемо
   використовувати автоматизовану систему теорем Lean від Microsoft Research.
   \paragraph{}
   Розбудовуючи певний фреймворк чи систему конструктивними методами
   так чи інакше доведеться зробити певний вибір у мові та способі кодування.
   Так при розробці теорії абстрактної алгебри в Coq були використані
   поліморфні індуктивні структури\cite{coqalg}. Однак Agda та Idris використувують
   для побудови алгебраїчної теорії типи класів, а у Idris взагалі відсутні
   поліморфірні індуктивні структури та коіндуктивні структури. В Lean
   теж відсутні коіндуктивні структури проте повністю реалізована теорія
   HoTT на нерекурсивних поліморфних структурах що обєднує основні чотири
   класи математичних теорій: логіка, топологія, теорія множин, теорія типів.
   Як було показано Стефаном Касом\cite{kaes}, одна з
   стратегій імплементації типів класів --- це використання поліморфних структур.
   Хоча в Lean також підтримуються типи класів нами була вибрана стратегія
   імплементації нашої теорії з використаннями нерекурсивних індуктивних структур,
   що дозволить нам оперувати з персистентними структурами на низькому рівні.
   Крім того такий спосіб кодування ієрархій повністю відповідає семантиці Erlang,
   де немає типів класів, а дані передаються запаковані в кортежі-структури.

  \subsubsection{Логіка та квантори}

Далі йдуть квантори $\forall$ та $\exists$ які теж виражаються як конструкції типів:

\begingroup
\parbox[t][][l]{0.40\textwidth}{

\begin{prooftree}
\AxiomC{$\Gamma\ x: A \vdash B$ }
\AxiomC{$\Gamma\ \vdash A$ }
\BinaryInfC{$\Gamma\ \vdash \Pi (x : A) B $}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Gamma\ x: A \vdash B$ }
\AxiomC{$\Gamma\ \vdash A$ }
\BinaryInfC{$\Gamma\ \vdash \Sigma (x : A) B $}
\end{prooftree}

}
\hspace{0.1cm}
\parbox[t][][r]{0.60\textwidth}{

\begin{prooftree}
\AxiomC{$\Gamma\ \vdash a : A$ }
\AxiomC{$\Gamma\ x : A \vdash B$ }
\AxiomC{$\Gamma\ b : B (x=a)$ }
\TrinaryInfC{$\Gamma\ \vdash (a,b) : \Pi (x : A) B $}
\end{prooftree}


\begin{prooftree}
\AxiomC{$\Gamma\ \vdash a : A$ }
\AxiomC{$\Gamma\ x : A \vdash B$ }
\AxiomC{$\Gamma\ b : B (x=a)$ }
\TrinaryInfC{$\Gamma\ \vdash (a,b) : \Sigma (x : A) B $}
\end{prooftree}

}
\endgroup

\begingroup
\parbox[t][][l]{0.40\textwidth}{

\begin{prooftree}
\AxiomC{$\Gamma\ \vdash x: A$ }
\AxiomC{$\Gamma\ \vdash x': A$ }
\BinaryInfC{$\Gamma\ \vdash Id_A (x,x')$}
\end{prooftree}

}
\hspace{0.1cm}
\parbox[t][][r]{0.60\textwidth}{

}\endgroup


\begin{center}
\begin{tabular}{lll}
  рефлексивність &:& $Id_A(a,a)$ \\
  підстановка     &:& $Id_A(a,a') \rightarrow B(x=a) \rightarrow B(x=a')$ \\
  симетричність  &:& $Id_A(a,b) \rightarrow Id_A(b,a)$  \\
  транзитивність &:& $Id_A(a,b) \rightarrow Id_A(b,c) \rightarrow Id_A(a,c)$ \\
  конгруентність &:& $(f: A \rightarrow B) \rightarrow Id_A(x,x') \rightarrow Id_B(f(x),f(x'))$ \\
\end{tabular}
\end{center}


\newpage
\subsection{Предмет дослідження}
\vspace{0.5cm}

   Предметом дослідження даної роботи є розробка формальних методів для побудови
   операційних середовищ та метамоделей для їх формальної специфікації. Розглянувши усі
   можливі математичні моделі опису формалізму процесів ми формуємо ряд вимог корисних
   для побудови ефективної моделі яка дозволить:

\begin{itemize}
   \item Скоротити об’єм коду на порядок
   \item Нормалізувати дані для їх статистичної обробки
   \item Легко обчислювати показники системи масового обслуговування
   \item Легко доводити коректність
   \item Мінімізувати цикл розробки програмного забезпечення
   \item Підвищити ефективність виконання
\end{itemize}

  Для забезпечення стратегії цієї роботи ми визначаємо найбільш оптимальну модель
  потоку даних та функції для їх обробки, використовуючи алгебраїчний підхід
  для опису протоколів та їх категорій. Серед основних фаз дослідження можна виділити:

\begin{itemize}
   \item Дослідження алгебраїчних структур середовища
   \item Визначення характеристик нормалізованих та оптимальних структур
   \item Побудова системи типів
   \item Визначення властивостей системи та доведення теорем
   \item Розробка системи додатків на основі метамоделі на мові Erlang
   \item Впровадження, діагностика та аналіз роботи системи
\end{itemize}

   \paragraph{}
   Іншими словами словом ми розроблюємо теорію та імплементацію мінімалістичного
   сертифікованого верифікованого операційного середовища для компонентів замнекненої системи:
   абстракції аппаратного забезпечення, мова програмування, віртуальна машина, комунікаційні
   черги, бази даних, веб сервери, сервери додатків, та усе, що піддається верифікації та по
   можливості є коректним за побудовою. Починаючи з фундаментального формалізму лямбда та пі числення,
   через абстракції віртуальної машини до віртуальної апаратури, реальні сучасні додатки та протоколи,
   закінчуючи прикладами, засобами та документацією на створене обчислювальне середовище та його модель.\\

\newpage
   \subsubsection{Алгебраїчний підхід}

   Ми будемо застосовувати алгебраїчні рекурсивні типи даних для побудови системи типів, тому
   зручно буде також застовувати алгебраїчний підхід до генералізації теорії процесів.
   З алгебраїчної точки зору процесси, або кінечні автомати, представляють собою напівгрупи дій.
   З категоріальної точки зору процесси --- це функтори які перетворюють категорії з декартовими добутками
   типів протоколу та стану процеса на категорію станів. Кожен процес визначається таким функтором, адже
   простір дій $\Sigma$ для кожного процесу є унікальний.

\begin{center}
\begin{tabular}{lcll}
$A$         &:& $\Sigma \times X \rightarrow X  $ &\\
$X$         &:& $\Sigma \times \Lambda_{X} $ &\\
            &|& $\bot                              $ &\\
$\Sigma$    &:& $ok$    & $\times\ \_$          \\
            &|& $error$ & $\times\ \_$          \\
            &|& $io$    & $\times\ \_ \times\ \_$          \\
\end{tabular}
\end{center}

   У функціональних мовах програмування така категорія будем мати вигляд програми,
   де функтор буде представлений фунцією перетворення станів процесу, а протокол
   буде типом-сумою усіх можливих запитів до процесу:

\begin{center}
\begin{lstlisting}[mathescape=true]
                  action : proto $\rightarrow$ state $\rightarrow$ state
                  state  : list proto
       definition sigma := ok + error + io

                  record proto := (data: iterator)
                  record ok    extends proto
                  record error extends proto
                  record io    extends proto := (effects: iterator)
\end{lstlisting}
\end{center}

  \subsubsection{Напівгрупа активностей}

  Дана алгебраїчна модель визначає достатньо просту та визначену структуру.
  Мета нашої структури забезпечити детермінованість послідовності,
  її початковий елемент та термінальний. 

\begin{center}
\begin{tabular}{lcl}
$spawn$       &:& $\top\ \rightarrow\ S$\\
$run$         &:& $S\ \rightarrow\ \bot$\\
$\bot$        &:& $\odot\ S\ \rightarrow\ S$\\
$complete$    &:& $\otimes\ S\ \rightarrow\ S$\\
\end{tabular}
\end{center}

  Одиниця напівгрупи
  демонструється номінально як операція запиту поточного стану процеса.
  Інша бінарна операція напівгрупи по відношеню до протокола та стану процеса $complete$
  передбачає виконання функції активності поточного кроку процесу, яка
  визначена в сигнатурі як $action: \Sigma\ \rightarrow\ P\ \rightarrow\ P$.

\begin{center}
\begin{lstlisting}[mathescape=true]

      record app (P S: Type) := (spawn  : P $\rightarrow$ S)
                                (run    : S $\rightarrow$ P)
                                (action : P $\rightarrow$ S $\rightarrow$ S)

\end{lstlisting}
\end{center}

  \subsubsection{Лінійність обчислень}
   Списки є фундаментальними структурами та найпростішим рекурсивним алгебраїчним типом.
   Природа обчислень, як результат виконання процессів теж лінійна. Можна навіть визначити
   оператор похідної, як функтор, який для алгебраїчного типу процесу буде давати список,
   а для списку буде давати скаляр. Як було показано \cite{meseguer} мережі петрі,
   а значить і процеси є моноїдами які генерують лінійну послідовність подій.

\begin{center}
\begin{tabular}{lcl}
$\Delta \ \Lambda^0$         &:& $\times^0$ \\
$\Delta \ \Lambda^{n}$       &:& $\Lambda^{n-1}$ \\
\end{tabular}
\end{center}

   \paragraph{}
   Саме лінійність кінцевого
   процессу виконання певного структурованого або циклічного алгоритму відіграє ключову
   роль у моделюванні віртуальних обчислювальних середовищ. Такі лінеаризовані системи
   уже показали свою ефективність в певному класі обчислень, таких як ланцюгова реплікація,
   реактивні системи, та інші моделі напівгруп навколо певних типів -- протоколів взаємодії між процесами.
   Крім того такі послідовності подій піддаються статистичній обробці для визначення первних кластеризацій
   та інших кореляцій у просторі та часі, тому можна говорити про певні зручні, нормалізовані системи типів для
   такого роду маніпуляцій над даними.

  \subsubsection{Управління ефектами}
   Однак що робити коли обчислення в моноїдальних категоріях проходять з помилками?
   Як обробляти ці помилки, та як ці помилки пов’язані зі слідом процесу? Таким чином кажуть
   про ефекти які можуть виникнути при роботі чистих функцій.
   Кодування ефектів за допомогою типів зараз є стандартом
   де-факто в сучасних функціональних мовах програмування. Так наприклад в мові Haskell ефекти кодуються
   за допомогою монадичних типів. Однак, насправді, достатньо було б використовувати менш загальний спосіб
   кодування єфектів у вигляді списків, з огляду на лінійність процесу обчислень. Так в мові Idris
   ефекти середовища дійсно представлені у вигляді списків. Як показано\cite{baer}, ефекти
   навіть вносяться як мовні елементи у функціональну мову, як це наприклад існує
   в імперативних мовах у вигляді типів виняткових ситуації.

   \paragraph{}
   Класично до ефектів, крім помилок та виключень, відносять також усі
   операції що взяємодіють зі змінними за межами локального контексту
   виконання функції (параметри чи локальні змінні в стеку функції).
   Також до ефектів відносят стан процессу що знаходиться контекстом
   вище ніж контекст даної функції. Однак в нашій моделі стан включений
   явно у сигнатури наших моноїдальних конструкцій.

   \paragraph{}
   Ми хочемо зробити так, аби ефекти були явними готовими до персистентності.
   Наприклад щоби можно було взяти послідовність ефектів у вигляді списку і
   передати їх по мережі чи зберегти у сховищі середовища. Таким чином ми
   пропонуємо відкриту модель кодування ефектів у вигляді дво-зв’язних
   списків (сигнатура бінарного дерева з аксесорами $next$ та $prev$).

   \paragraph{}
   Мотивація такого підходу полягає в тому, що для транзакційних систем
   в яких існує лог операцій, цей лог операції і є ефектими які виникають в процесі обчислень.
   І в розподілених системах зручно явно оперувати такими ланцюгами ефектів.
   Тому ми описуємо універсальних механізм зберігання поліморфних структур
   на базі абстрактного key-value яке нам пропонує віртуальна машина, і ефекти
   ми будемо кодувати індуктивними поліморфними структурами. Кожна послідовність ефектів та обчислень
   кодується певним типом та зберігається у сховищі під унікальним ключем. В процесі роботи
   система оперує обчисленнями як послідовностями, і може їх склеювати, підрізати,
   пробігати та згортати.

   \paragraph{}
   Ми почнемо з двох найголовніших послідовностей $ok$ (послідовніст обчислень)
   та $error$ (послідовність помилок), а також об’єднана стурктура $io$ яка тримає
   обидва вида ефектів. Результат обчислень кожної функції ($ok$ чи $error$ в залежності від результату)
   дописуєтся у відповідний ланцюг контейнера ефектів який знаходиться близько до
   процесу який тримає стан і виконує дану функцію.

\begin{center}
\begin{tabular}{llll}
$KVS$     &:& $get$    & $\times\ \_$          \\
          &:& $put$     & $\times\ \_$          \\
          &|& $add$     & $\times\ \_$          \\
          &|& $remove$  & $\times\ \_$          \\
          &|& $cut$     & $\times\ \_$          \\
          &|& $append$  & $\times\ \_$          \\
          &|& $fold$    & $\times\ \_$         \\
\end{tabular}
\end{center}

\begin{center}
\begin{lstlisting}[mathescape=true]

  definition ids       := option $\mathbb{N}$
      record container := (top: ids) (size: $\mathbb{N}$)
      record iterator  := (id: ids) (next: ids) (prev: ids)

      record db      extends proto
      record get     extends db
      record put     extends db
      record add     extends db
      record cut     extends db
      record remove  extends db
      record append  extends db
      record fold    extends db
  definition kvs :=  get + put + add + remove +
                     append + fold + ok + error + io

      record store
     extends app kvs container :=
             (sup: list container)
             (tab: list table)
             (calculation: iterator $\rightarrow$ container $\rightarrow$ container)

\end{lstlisting}
\end{center}

\newpage
   \subsubsection{Визначення процесу}

   Щоб формально визначини процес ми спочатку визначимо типи,
   які фігурують при визначенні процесу.

\begin{center}
\begin{tabular}{lcl}
                Errors &:& \#error\\
              Sucesses &:& \#ok \\
           Environment &:& \#document | \#config\\
              Taxonomy &:& \#event    | \#task   | \#flow\\
                Module &:& $\{ action : \Sigma \rightarrow P \rightarrow P \}$ \\ \hline
               Process &:& \#process\\
\end{tabular}
\end{center}

\begin{center}
\begin{lstlisting}[mathescape=true]
            record task      := (name: string)
            record event     := (name: string)
            record flow      := (source: task) (target: task)
            record process
           extends iterator :=
                   (env: list iterator)
                   (feed_id: $\mathbb{N}$)
                   (taxonomy: prod (prod (list task) (list flow)) (list event))
\end{lstlisting}
\end{center}

   \subsubsection{Управління процесами}

\begin{center}
\begin{tabular}{llll}
 $BPE$      &:& $amend$       & $\times\ \_$      \\
            &|& $complete$    & $\times\ \_$         \\
            &|& $run$         & $\times\ \_$          \\
\end{tabular}
\end{center}

\begin{center}
\begin{lstlisting}[mathescape=true]
            record p        extends proto
            record run      extends p
            record amend    extends p
            record complete extends p
        definition bpe := run + amend + complete + ok + error + io

            record proc
           extends app bpe process :=
                   (sup: list process)

\end{lstlisting}
\end{center}

  \subsubsection{Контраваріантні процеси}

  Ко-процеси це процеси у яких напрямок обчислення обернений, для цього
  згортка оберненої рекурсії повинна виконуватися оберненою функцією до стану процесу.
  Оберненої функції-функтора процесу може і не існувати. Процеси які є
  одночасно коваріантними та контраваріантними називаються інваріантними процесами, сигнатура яких
  алгебраїчно збігається з сигнатурою бінарного дерева.

\begin{center}
$st(p) = p(st-1)$ — застосування функції до протокольної заявки та стану процесу
$p-1(st) = st-1$ — обернена функція
\end{center}

\newpage


\subsection{Сигнатури сервісів}

{\bf app}    --- веб сервер додатків, та комутатор протоколів\\
{\bf proc}   --- дводольний граф обчислень для бізнес-процесів\\
{\bf store}  --- сховище ланцюгових послідовностей\\

Веб сервер додатків у своєму контексті зберігає різноманітні таблиці для різного
роду даних (cache, cookies, session), а також управляє процесами користувачів,
до яких підключаються певні протоколи в залежності від запитів користувачів.
Тому у його сигнатурі ми побачимо два списки: список таблиць та список процесів.

\paragraph{}
Для сховища лінійних послідовностей сигнатура сервсів буде включати
список усіх таблиць сховища де зберігаюьтся кортежі елементів послідовносетй,
їхні генератори унільних ідентифікаторій, а також список усіх унікальних послідовностей.

\paragraph{}
Для бізнес процесів сигнатура сервіса найпростіша: це просто список бізнес процесів,
для кождого з яких тримається послідовність ефектів (feed) у сховищі kvs.

\begin{center}
\begin{tabular}{lll}
           $store^3$ &:& $\times^3 \Lambda_{id_seq}\ \Lambda_{table}\ \Lambda_{feed}$ \\
             $app^2$ &:& $\times^2 \Lambda_{tables}\ \Lambda_{procs}$ \\
             $act^1$ &:& $\times^1 \Lambda_{procs}$ \\
\end{tabular}
\end{center}

\subsection{Віртуальна машина}

\begin{figure}[h!]
\centering
\includegraphics[scale=0.3]{img/exe-legend}
\caption{Базові елементи віртуального середовища}
\end{figure}

{\bf action} --- функція яка застосовується до протокольного повідомлення\\
{\bf record} --- кортеж у якому кодується протокольне повідомлення\\
{\bf client} --- користувач системи представлений у вигляді процеса\\
{\bf server} --- процес який обслуговує клієнтів та реагує на протокол\\
{\bf feed}   --- збережена послідовність обчислень\\
{\bf table}  --- масив кортежів з B-tree індексами\\

\newpage

\subsection{Мета дослідження}
\vspace{0.5cm}
   Основною метою дослідження є збезпечення виконання критеріїв відповідності
   показників ефективності, детермінованості та якості шляхом впровадження
   результату даної теорії, комплексу програмного забезпечення у виробничий процес.

   За рахунок компактності передбачається значна економія складності та простота у експлуатації,
   що веде до сниження собівартості впровадження. Коректність передбачає заміну
   автоматозаваному тестуванню, а закритість середовища дозволяє гнучко використовувати
   середовище на різних виробничих платформах.
   \\

\subsection{Результати}
\vspace{0.5cm}
   Результати будут представлені з точки зору: показників ефективності на
   прикладі розміру бібліотек та результатах впровадження; показники швидкодії
   у вигляді графіку навантаження, що показує ємність системи; та показники
   швидкодії персистентного сховища у застосуванні до розподілених систем на
   прикладі розподіленої бази даних, що працює за протоколом ланцюгової реплікації.

\begin{itemize}
   \item Показники ефективності
   \item Застосування у телекомунікаційних додатках
   \item Застосування у розподілених системах
\end{itemize}

\subsubsection*{Показники ефективності}
   У виробництві, після коректності, розмір є одним з найважливіших чинників.
   Адже ціна обслуговування, та загальна складність системи зі зменшенням обсягу продуку
   зменшується, що дає змогу більш оперативно вносити зміни до системи, а також
   зменшує час для адаптації операторам системи. Крім того, програмістам набагато
   комфортніше працювати з малими об’ємами коду да добре структурованими та компактними проектами.
   Покажемо у цифрах переваги нашої системи для мови Erlang:
   \\
   \\

\begin{center}
    \begin{tabular}{ | l | l | l | p{9cm} |}
    \hline
    Бібліотека & LOC  & Size,KB  & Опис \\ \hline
          LING & 64K  & 1800 & Віртуальна Машина на мові C\\
  \hline
           PIE & 5.6K & 350  & Emacs-подібний текстовий редактор\\
           CR  & 2.2K & 156  & Chain Replication база даних з XA протоколом\\
           N2O\footnote{http://github.com/synrc/n2o} & 1.2K & 124  & Мультиплікатор протоколів та веб додатки\\
           MAD & 980  & 116  & rebar.config сумісний менеджер пакетів \\
           KVS\footnote{http://github.com/synrc/kvs} & 1.2K & 92   & Персистентність ефектів\\
           BPE\footnote{http://github.com/spawnproc/bpe} & 650  & 72   & Система управління бізнес-процесами BPMN 2.0\\
          LDAP & 730  & 64   & LDAP сервер\\
           MQS & 300  & 28   & AMQP клієнт\\
  \hline
    \end{tabular}
\end{center}

\newpage
\subsubsection*{Застосування у телекомунікаційних додатках}
Щодо аргументації швидкості, та вибору платформи, ми пропонуємо велику конгрегацію
веб фреймворків сучасних функціональних та імперативних мов програмування: Сюди увійшли
Haskell (Warp), OCaml (OCsigen), Erlang (Cowboy/N2O), Clojure (http-kit), JavaScipt (Node), Go (gohttp), D (Vibe).
Як видно з графіка у вищий клас попали Haskell, Java та Erlang HTTP стеки.
Тестування проводилося за допомогою утіліти {\bf wrk} для HTTP трафіку, та {\bf tcpkali} для WebSocket трафіку.
Тому можно з впевненістю сказати, що Erlang якнайкраще підходить у тому числі для веб додатків,
завдяки своїм телекомунікаційним властивостям. Крім того завдяки відсутності непотрібних прошарків
у системи можно побачити, що N2O мінімально впливає на пропускну спроможність тракту.

\begin{figure}[h!]
\centering
\includegraphics[scale=0.5]{img/connections}
\caption{Навантаження яке витримує N2O}
\end{figure}

Спосіб представлення функціональності веб-додатків у вигляді модуля який
представляє єдину функцію напівгрупи активностей та реагує на унікальний протокол повідомлень
добре зарекомендував себе у виробництві, так система з 18 протоколами,
96 формами та 24 зовнішніми сервісами які мають 55 точок підключення
була впроваджена протягом одного року відділом з трьох програмістів.
Система завдяки сховищу KVS підтриує необмежені лінійні (впорядковані у часі)
ідентифікатори, версії кортежів та протокольних повідомлень, різні сховища нижчого рівня,
у тому числі і стандартне сховище Erlang -- {\bf mnesia}.

\newpage
\subsubsection*{Застосування у розподілених системах}
\paragraph{}
Що стосується швидкості системи сховища ефектів, то тут хочеться представити
імплементацію транзакційного сховища CR\cite{renesse1} з послідовностями KVS
у якості транзакційного журналу. У якості алгоритму оракула був
вибраний алгоритм RAFT\cite{renesse2}. Як відомо, алгоритм ланцюгової реплікації
помоножує латенсі усіх нод, на відміну від бродкаст алгоритмів типу PAXOS,
однак значно економить міжпротокольний трафік та зберігає простоту алгоритму.
Ми реалізували алгоритм ланцюгової реплікації на базі KVS в якості операційного журналу,
та отримали наступні результати.

Для трьох машин у локальній мережі ми маємо середне значення latency у розмірі 100мс
при реплікації на три машини і 300мс максимальне значення для бази даних {\bf mnesia}
у конфігурації {\bf disc\_copies}.

\begin{center}
\begin{lstlisting}[mathescape=true,basicstyle=\tiny]
                                               vnode   i  n        top      log        latency
    121791803110908576516973736059690251637994378581   1  1       6506     1607       1/315/97
    243583606221817153033947472119380503275988757162   2  1       6508     1662      1/317/100
    365375409332725729550921208179070754913983135743   3  1       6510     1658      2/317/105
    487167212443634306067894944238761006551977514324   4  1       6505     1583      1/317/104
    608959015554542882584868680298451258189971892905   5  2       6499     1637      3/317/115
    730750818665451459101842416358141509827966271486   6  2       6510     1664      2/318/117
    852542621776360035618816152417831761465960650067   7  2       6501     1634      2/311/115
    974334424887268612135789888477522013103955028648   8  2       6500     1575       3/290/96
   1096126227998177188652763624537212264741949407229   9  3       6497     1607      3/316/118
   1217918031109085765169737360596902516379943785810  10  3       6510     1662      3/318/117
   1339709834219994341686711096656592768017938164391  11  3       6496     1658      3/311/106
   1461501637330902918203684832716283019655932542972  12  3       6505     1583      2/295/104
\end{lstlisting}
\end{center}


\newpage
\subsection*{Додаток А. Персистентність послідовностей}

Для забезпечення персистентного зберігання послідовностей використовується
очевидний спосіб зберігання елементів послідовності у key-value сховищі разом
з референсами на наступні, та у випадку контраварінтних процесів, також і на
попередні елементи у послідовності. Таким чином ми можемо перелічити усі
елементи послідовності. Акумулятор розділеної у просторі та часі операції
накопичує усі необхідні агрегації після кожної операції з послідовністю. Таким
чином похідна від алгебраїчної структури списку буде скаляр-акумулятор після
завершення перелічення.

\begin{figure}[h!]
\centering
\includegraphics[scale=0.4]{img/exe-kvs-api}
\caption{Типи, функції та модулі}
\end{figure}

В даній роботі ми розглянемо формальні визначення сховища, його референсів, послідовностей через рекурсивні
алгебраїчні типи даних та процеси, черги яких забезпечують впорядкованість послідовності
запитів до послідовностей, що веде до лінійності операції у часі.

\begin{figure}[h!]
\centering
\includegraphics[scale=0.4]{img/exe-kvs}
\caption{Послідовності ключів, таблиць, індексів та інтерфейс}
\end{figure}

\newpage
\subsection*{Додаток Б. Мультипротокольный чат}

\begin{figure}[h!]
\centering
\includegraphics[scale=0.1]{img/exe-roster-api}
\caption{Типи, функції та протокол}
\end{figure}

\begin{figure}[h!]
\centering
\includegraphics[scale=0.3]{img/exe-roster}
\caption{Cписки кімнат та користувачів і їхні чати, дві таблиці та протокол}
\end{figure}



\newpage
\begin{thebibliography}{9}

\bibitem{lof}      Per Martin-Löf \textit{Intuitionistic Type Theory.} 1984
\bibitem{comm}     Robin Milner. \textit{ A Calculus of Communicating Systems.} 1986.
\bibitem{lawvere}  William Lawvere. \textit{Conceptual Mathematics.} 1997.
\bibitem{pierce}   Benjamin Pierce. \textit{Basic category theory for computer scientist.} 2004.
\bibitem{mclane}   Сандерс Мак Лейн. \textit{Категории для работающего математика.} 2004.
\bibitem{tla}      Leslie Lamport. \textit{Specifying Systems.} 2004.
\bibitem{barrtri}  Michael Barr and Charles Wells. \textit{Toposes, Triples and Theories.} 2000.
\bibitem{barrcat}  Michael Barr and Charles Wells. \textit{Category Theory for Computing Science.} 1995.
\bibitem{bakur}    И.Бакур, А.Деляну. \textit{Введение в теорию категори и функторов.} 1972.
\bibitem{commpi}   Robin Milner. \textit{Communicating and Mobile Systems: The $\pi$-calculus.} 1999.
\bibitem{polypi}   Robin Milner. \textit{The Polyadic $\pi$-Calculus: A Tutorial.} 1993.
\bibitem{mass}     Коваленко. \textit{Теория Массового Обслуживания.} 1965.
\bibitem{meseguer} Meseguer, Montanari.  \textit{Petri Nets Are Monoids.} 1990.
\bibitem{waddual}  Philip Wadler \textit{Call-by-Value is Dual to Call-by-Name.} 1000
\bibitem{seserl}   D.Mostrous, V.Vasconcelos \textit{Session Typing for a Featherweight Erlang.} 1990.
\bibitem{suberl}   S.Marlow, P.Wadler \textit{A practical subtyping system for Erlang.} 1997
\bibitem{upserl}   A.Lindgren \textit{A Prototype of a Soft Type System for Erlang.} 1996
\bibitem{mcbride}  C. McBride. \textit{Dependently Typed Func- tional Programs and their Proofs.} 1999
\bibitem{mcbrider} C. McBride. \textit{The Derivative of a Regular Type is its Type of One-Hole Contexts.}
\bibitem{schwarz}  C. Schwarzweller. \textit{Mizar Veri cation of Generic Algebraic Algorithms.} 1997
\bibitem{mourael}  L.Moura., S.Kong \textit{Elaboration in Dependent Type Theory.} 1997
\bibitem{coqhuet}  T.Coquand, G.Huet \textit{The Calculus of Constructions.} 1988
\bibitem{lampax}   L.Lamport \textit{Paxos Made Simple.} 2001
\bibitem{harpl}    R.Harper \textit{Practical Foundations for Programming Languages} 2015
\bibitem{chipvm}   A.Chlipala \textit{Certified Programming with Dependent Types} 2015
\bibitem{idris}    E.Brady \textit{Programming in IDRIS: A Tutorial} 2015
\bibitem{baer}     A.Baer \textit{Programming with Algebraic Effects and Handlers} 2012
\bibitem{chipintro} A.Chlipala \textit{An Introduction to Programming and Proving with Dependent Types in Coq} 2010
\bibitem{coqalg}   H.Gueves, R.Pollak, F.Wiedijk, J.Zwanenburg \textit{A Constructive Algebraic Hierarchy in Coq} 2002
\bibitem{kaes}     S.Kaes \textit{http://tuprints.ulb.tu-darmstadt.de/epda/000544/diss.pdf} 2005
\bibitem{agdaio}   A.Jeffrey, J.Rathke \textit{The Lax Braided Structure of Streaming I/O} 1998
\bibitem{bell}     A.Jeffrey \textit{Linear-time Temporal Logic Propositions as Types Proofs as Functional Reactive Programs} 2012
\bibitem{wadler}   P.Wadler \textit{Propositions as Types} 2014
\bibitem{moneff}       N.Benton, J.Hughes,E.Moggi \textit{Monads and Effects} 2002
\bibitem{mcbrideapp}   C.McBride, R.Patterson \textit{Applicative programming with effects} 2002
\bibitem{baastad}      P.Wadler \textit{Monads for functional programming} 
\bibitem{renesse1} H.Abu-Libdeh, R.Renesse, Y.Vigfusson \textit{Leveraging Sharding in the Design of Scalable Replication Protocols}
\bibitem{renesse2} R.Renesse, C.Ho, N.Schiper \textit{Byzantine Chain Replication}
\bibitem{renesse3} R.Renesse, N.Schiper \textit{Chain Replication for Supporting High Throughput and Availability}
\bibitem{erl}      J.Armstrong. \textit{Making reliable distributed systems in the presence of sodware errors.} 2003.
\bibitem{curien1} PL. Curien \textit{Category theory: a programming language-oriented introduction} 2008


\end{thebibliography}

\end{document}
