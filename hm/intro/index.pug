extends ../../layout.pug

block title
    title HN

block content
    +header('http://groupoid.space/groupoid.svg', 'HN', 'Language Intoduction')
    article.main
        aside Andy Melnikov
            time 17 JAN 2017
        .intro
            h2 HN Language
            p.
                HN is an implicitly typed language.
                The type inference algorithm is complete, so there are no type annotations.
                The primitives are very similar to the original Milner's proposal for ML language:
                lexically scoped variables, functions, assignments, loops and conditionals.
            h2 Syntax
            p.
                There are expressions and types. Expressions are in essence
                the lamda caclulus enriched with Let construct. The types
                are function types, simple constant types, parametrised
                polymorphic container types and type schemes.
            code.
                    Inductive E := Var: name → E
                                 | App: E → E → E
                                 | Lambda: name → E → E
                                 | Let: name → E → E.
            code.
                    Inductive T := Simple: name → T
                                 | Parametrized: name → list name → T
                                 | Var: name → T
                                 | Scheme: list name -> T -> T
                                 | Arrow: T → T → T.
            p.
                To make code more human-readable HN disallows lambdas and requires
                all functions to be named.
                So the actual abstract syntax of HN0 is more complex:

            code.

                data LetIn a = Let (Definition a) (LetIn a)
                             | In (Expression a)

                data Definition a = Definition a [a] (LetIn a)
                                  | Assign a (LetIn a)
                                  | While Expression LetIn
                                  | If Expression LetIn LetIn

                data Expression a = Application (Expression a) [Expression a]
                                  | Atom a
                                  | Constant Const

                data Const = ConstString String
                           | ConstInt    Int

            p.
                However, HN is a compiler intermediate language for human-readable code generation,
                so there are many limitations compared to what you ususally expect from an ML dialect.
            p.
                Common Limitations: Type-safe but not memory-safe; Controlled effects;
                No recursion; No currying or partial applications;
                No currying or partial applications.
            p.
                Unusual Limitations: FFI import is the only way to create data types;
                All functions must be named;
                Only stack-allocated variables and closures;
                Closures can't escape the scope;
                Explicit heap deallocations.

            code.
                 hnMain = {
                     g x count = {
                         f xx = _or (eq 0 (mod xx 5)) (eq 0 (mod xx 3))
                         _if (f x) (sum count x) count
                     }
                     print (natrec g 0 999)
                 }

            code.
                 #include <hn/lib.hpp>
                 struct hnMain_impl
                 {
                      static int g(int x, int count)
                      {
                           return 0 == x % 5 || 0 == x % 3 ? count + x : count;
                      };
                 };
                 ff::IO<void> hnMain()
                 {
                      typedef hnMain_impl local;
                      return ff::print(ff::natrec<int>(&local::g, 0, 999));
                 };

             p.
                 The abstract syntax is defined in `Parser.AST` module by mutually recursive
                 algebraic data types, nothing unusual or exotic here:
             p.
                 The AST has two forms: the parser returns `Definition String` but
                 optimizer converts it into `Definition Label` with unambiguously resolved names.
             p.
                 The `Parser.Parser` module contains two parsers - `program` and `identifier`
                 and Parsec library is the only dependency.
             p.
                 Put `min-parser.hs` to the project root:

             code.
                 import Parser.Parser
                 import Text.Parsec.ByteString

                 main = parseFromFile program "hn_tests/euler1.hn" >>= print

             code.
                 $ cabal exec runhaskell -- -Wno-tabs min-parser.hs

                 Right [Definition "hnMain" [] (Let (Definition "g" ["x","count"]
                 (Let (Definition "f" ["xx"] (In "_or" "eq" 0 "mod" "xx" 5 "eq" 0
                 "mod" "xx" 3)) (In "_if" "f" "x" "sum" "count" "x" "count"))) (
                 In "print" "natrec" "g" 0 999))]
