extends ../../layout.pug

block title
    title HN

block content
    +header('http://groupoid.space/groupoid.svg', 'HN', 'Language Intoduction')
    article.main
        aside Andy Melnikov
            time 17 JAN 2017
        .intro
            h2 Motivation
            p.
                HN is an implicitly typed language.
                The type inference algorithm is complete, so there are no type annotations.
                The primitives are very similar to the original Milner's proposal for ML language:
                lexically scoped variables, functions, assignments, loops and conditionals.
            h2 Internal Language
            p.
                There are expressions and types. Expressions are in essence
                the lamda caclulus enriched with Let construct. The types
                are function types, simple constant types, parametrised
                polymorphic container types and type schemes.
            code.
                    Inductive E := Var: name → E
                                 | App: E → E → E
                                 | Lambda: name → E → E
                                 | Let: name → E → E.
            code.
                    Inductive T := Simple: name → T
                                 | Parametrized: name → list name → T
                                 | Var: name → T
                                 | Scheme: list name -> T -> T
                                 | Arrow: T → T → T.
            h2 Syntax
            p.
                To make code more human-readable HN disallows lambdas and requires
                all functions to be named.
                So the actual abstract syntax of HN0 is more complex:

            code.

                data LetIn a = Let (Definition a) (LetIn a)
                             | In (Expression a)

                data Definition a = Definition a [a] (LetIn a)
                                  | Assign a (LetIn a)
                                  | While Expression LetIn
                                  | If Expression LetIn LetIn

                data Expression a = Application (Expression a) [Expression a]
                                  | Atom a
                                  | Constant Const

                data Const = ConstString String
                           | ConstInt    Int

            h2 Limitations
            p.
                However, HN is a compiler intermediate language for human-readable code generation,
                so there are many limitations compared to what you ususally expect from an ML dialect.
            p.
                Common Limitations: Type-safe but not memory-safe; Controlled effects;
                No recursion; No currying or partial applications;
                No currying or partial applications.
            p.
                Unusual Limitations: FFI import is the only way to create data types;
                All functions must be named;
                Only stack-allocated variables and closures;
                Closures can't escape the scope;
                Explicit heap deallocations.

            h2 Code Generation Example
            code.
                 hnMain = {
                     g x count = {
                         f xx = _or (eq 0 (mod xx 5)) (eq 0 (mod xx 3))
                         _if (f x) (sum count x) count
                     }
                     print (natrec g 0 999)
                 }

            code.
                #include &lt;hn/lib.hpp&gt;
                struct hnMain_impl
                {
                  static int g(int x, int count)
                  {
                    return 0 == x % 5 || 0 == x % 3 ? count + x : count;
                  };
                };
                ff::IO<void> hnMain()
                {
                  typedef hnMain_impl local;
                  return ff::print(ff::natrec<int>(&local::g, 0, 999));
                };

            h2 AST Inspection
            code.
                import Parser.Parser
                import Text.Parsec.ByteString
                main = parseFromFile program "hn_tests/euler1.hn" >>= print
            code.
                $ cabal exec runhaskell -- -Wno-tabs min-parser.hs
                Right [Definition "hnMain" []
                (Let (Definition "g" ["x","count"]
                     (Let (Definition "f" ["xx"]
                          (In "_or" "eq" 0 "mod" "xx" 5 "eq" 0 "mod" "xx" 3))
                          (In "_if" "f" "x" "sum" "count" "x" "count")))
                     (In "print" "natrec" "g" 0 999))]
