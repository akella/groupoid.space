<!DOCTYPE html><html><head><meta charset="utf-8"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="author" content="Maxim Sokhatsky"><meta property="og:title" content="Groupoid Infinity"><meta property="og:image" content="//groupoid.space/grp.png"><meta property="og:type" content="website"><meta property="fb:app_id" content="118554188236439"><meta property="og:url" content="//groupoid.space"><meta property="og:description" content="Infinity Language"><link rel="stylesheet" href="//groupoid.space/main.css"><title>Runtime</title></head><body class="content"><header class="header"><a href="//groupoid.space/"><img class="header__logo" src="//groupoid.space/groupoid.svg"/></a><div class="header__titles"><h1 class="header__title">Interpreter Runtime</h1><h4 class="header__subtitle">AMP Scheduler, CAS Queues, CPS Tasks</h4></div></header><article class="main"><h2 id="Abstract">Low Latency Transport</h2><p>The InterCore bus constructed of number of SPMC queues per core. The bus itself
has start topology between cores and MPSC is organized as a computable function
over a set of publisher queues. Each core has exatcly one publisher queue.</p><p>The InterCore protocol handler is called <b>poll_bus</b> and is a member of
each <b>Scheduler</b>. You may think of InterCore as teleport trasnport between
processors as <b>poll_bus</b> is being fired on each yield to scheduler and
if any core has any message addressed to you since last yield on your
core, then your core before next task will execute the handler on this message.
</p><h2 id="Publisher">Publisher [capacity]</h2><p><b>pub</b> creates new publisher CAS cursor for writing.
Returns system-wide cursor Id.</p><code>o) p: pub[16]
</code><h2 id="Subscriber">Subscribe [publisher]</h2><p><b>sub</b> created new subscriber CAS cursor based on given writer cursor.
Return system-wide cursor Id for reading.</p><code>o) s: sub[p]
</code><h2 id="Spawn">Spawn [core program cursors]</h2><p><b>spawn</b> created new Task on a given core. The Task could be O program
or any LLVM code with compatible FFI. Also you should specify the ownership
list of cursors that are exclusively available to that Task.</p><code>o) spawn [0 "etc/proc0" (0;1)]
</code><h2 id="Send">Send [writer data]</h2><p><b>snd</b> sends particular data to a given writer cursor. Returns nil if OK.</p><code>o) snd[p;42]
</code><h2 id="Receive">Receive [reader]</h2><p><b>rcv</b> returns data from the given reader cursor.
If none then yields to scheduler for another task.</p><code>o) rcv[s]</code></article><footer class="footer"><img class="footer__logo" src="https://longchenpa.guru/seal.png" width="50"><span class="footer__copy">2016&mdash;2017 &copy; Groupoid Infinity</span></footer><script src="//groupoid.space/bundle.js"></script><script src="//groupoid.space/highlight.js"></script></body></html>