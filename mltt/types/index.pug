extends ../../layout.pug

block title
    title Types

block content
    +header('../../groupoid.svg', 'Infinity Types', 'Inductive Base Library')
    article.main
        .om
            section
                h1 Article
        .types
            h2 The Design of Base Library
            -
                    var types = {
                        'nr nd +': ['bool', 'true', 'false', 'maybe', 'unit'],
                        'r nd +': ['nat', 'list', 'io', 'ioi'],
                        'nr d +': ['path', 'exists', 'iso', 'equiv'],
                        'rd +': ['vector'],
                        'nr nd *': ['prod', 'pure', 'functor', 'applicative', 'monad'],
                        'r nd *': ['stream', 'process', 'effect', 'eff.monad', 'eff.handler'],
                        'nr d *': ['sigma', 'setoid', 'proper', 'respect' ],
                        'rd *': ['cat', 'propset', 'groupoid']
                    }

                    var legend = {
                        'n': 'Not a',
                        'r': 'Recursive',
                        'd': 'Dependent',
                        '+': 'Coproducts',
                        '*': 'Products'
                    }

            .type
                for v, k in types
                    ol.type__col
                        h3= k.toUpperCase()
                        for i in v
                            li: a(href='#'+i)= i.toUpperCase()
            .legend
                for v, k in legend
                    ul.legend__col
                            li= `${k.toUpperCase()}: ${v}`

        .om
            section
                h1 Coproducts
        section
            p.
                Inductive types are the dependent version of generalized algebraic data types used in ML. With inductive and coinductive types you can model polynomial higher order functors that define generic trees and their constructors. Two very basic and known inductions are over natural numbers and lists, we show them the more detailed description.

            h2#nat Nat
            p.
                Pointed Unary System is a category nat with the terminal object
                and a carrier <mark>nat</mark> having morphism <mark>[zero: 1<sub>nat</sub> → nat, succ: nat → nat]</mark>. The initial object of nat is called Natural Number Object and models Peano axiom set.
            code.
                data nat = zero | succ (n:nat)

            h2 <a name='maybe'><a href='maybe/'>Maybe</a></a>
            p.
                Maybe has representing functor M<sub>A</sub>(X) = 1 + A.
                It used for wrapping values with optional nothing consdtructor.
                In ML-style languages this type is called Option (Miranda, ML).
            code.
                data maybe (A: U) = nothing | just (x: A)

            h2 <a name='list'><a href='list/'>List</a></a>
            p.
                The data type of <mark>list</mark> over a given set A can
                be represented as the initial algebra (&mu;&nbsp;L<sub>A</sub>,&nbsp;in)
                of the functor L<sub>A</sub>(X) = 1 + (A &times; X).
                Denote &mu; L<sub>A</sub> = List(A). The constructor
                functions nil: 1 &rightarrow; List(A) and cons: A
                &times; List(A) &rightarrow; List(A) are defined
                by nil = in ◦ inl and cons = in ◦ inr, so
                in = <mark>[nil,cons]</mark>.

            code.
                data list (A: U) = nil | cons (x:A) (xs: list A)

                len (A: U): list A -> integer
                '++' (A: U): list A -> list A -> list A
                map (A B: U): (A -> B) -> list A -> list B
                filter (A: U): (A -> bool) -> list A -> list A

            h2#sum Either
            p.
                <mark>either</mark> is a meta-representation form of
                <mark>data</mark> inductive syntax construction.
            code.
                data either (A B: U) = left (x: A) | right (y: B)

            h2#empty Empty
            p.
                <mark>empty</mark> is a bottom type used as zero or terminal for <mark>sum</mark> inductive type. This type nas no constructors or with empty body.
            code.
                data empty =

            h2#bool Bool
            p.
                <mark>bool</mark> is run-time version of the boolean logic you may use in your general purpose applications. It has only two unit constructors <mark>[true,false]</mark> and functions: <mark>[and,or]</mark>.
            code.
                data bool = false | true

            h2#vector Vector
            p.
                <mark>vector</mark> is the inductive defintion of limited length list.
                Through it depends on term <mark>nat</mark> it can be used on reasoning
                about single discrete dimention of the space, bringing very basic inductive logic. It can be used for reasoning about <mark>sqrt</mark>, as latter for any fractional exponent has correspondent number of roots inscribed in a circle on a complex surface. When vector is not dependent on nat its encoding should match with regular <mark>list</mark>.
            code.
                data vector (A: U) (n: nat)
                   = nil
                   | cons (x: A) (xs: vector A (pred n))
        .om
            section
                h1 Products
        section
            p.
                When you need to inspect the addendums of inductive tree
                defintions you can name the agruments of the constructor,
                these arguments called elements of the tuple or fields
                of the record. In this chapter we will use <mark>record</mark>
                Inf syntax, we only show how <mark>record</mark>
                and <mark>data</mark> are equal in example of
                <mark>unit</mark> and <mark>prod</mark> which
                are primitive forms of coinductive constructions.

            h2#prod Product
            code.
                data prod (A B: U) = mk (x: A) (y: B)
                prod (A B: U): U = (_: A) * B

                pi1 (A B: U) (x: prod A B): A = x.1
                pi2 (A B: U) (x: prod A B): B = x.2

            h2#unit Unit
            code.
                data unit = star

            h2 <a name='stream'><a href='stream/'>Stream</a></a>
            p.
                <mark>stream</mark> is a record form of the list's
                <mark>cons</mark> constructor. It models the infinity
                list that has no terminal element.
            code.
                data stream (A : U) = cons (x : A) (xs : stream A)

            h2 <a name='functor'><a href='functor/'>Functor</a></a>
            p.
                 Runtime functor.
            code.
                functor_ (F: U -> U): U = (A B: U) -> (A -> B) -> F A -> F B
            p.
                Functor carried with theorem fields.
            code.
                functor (F: U -> U): U
                    = (fmap: (A B: U) -> (A -> B) -> F A -> F B)
                    * (id: (A: U) -> (x: F A) -> Path (F A) (fmap A A (idfun A) x) x)
                    * (compose: (A B C: U) (f: B -> C) (g: A -> B) (x: F A) ->
                      Path (F C) (fmap A C (o A B C f g) x)
                    * Unit

            h2#applicative Control
            code.
                data fix (F: U -> U) = Fix (point: F (fix F))
                data freeF   (F: U -> U) (A B: U)  = ReturnF (a: A) | BindF (f: F B)
                data cofreeF (F: U -> U) (A B: U)  = CoBindF (a: A)         (f: F B)
                data free    (F: U -> U) (A: U)    = Free    (_: fix (freeF     F A))
                data cofree  (F: U -> U) (A: U)    = CoFree  (_: fix (cofreeF   F A))

                pure (F: U -> U): U
                    = (return: (A: U) -> A -> F A)
                    * Unit

                applicative (F: U -> U): U
                    = (pure_: (A: U) -> pure A F)
                    * (functor_: functor F)
                    * (ap: (A B: U) -> F (A -> B) -> F A -> F B)
                    * Unit

            h2#monad Monad
            code.
                monad (F: U -> U): U
                    = (pure_: (A: U) -> pure A F)
                    * (functor_: functor F)
                    * (join: (A B: U) -> F (F A) -> F B)
                    * Unit

                comonad (F: U -> U): U
                    = (pure_: (A: U) -> pure A F)
                    * (functor_: functor F)
                    * (extract: (A: U) -> F A -> A)
                    * (duplicate: (A: U) -> F A -> F (F A))
                    * (extend: (A B: U) -> (F A -> B) -> F A -> F B)
                    * Unit

            h2 <a name='sigma'><a href='sigma/'>Sigma</a></a>
            code.
                Sigma (A: U) (B: A -> U): U

                make (A: U) (B: A -> U) (a: A) (b: B a): Sigma A B
                pr1 (A: U) (B: A -> U) (x: Sigma A B): A
                pr2 (A: U) (B: A -> U) (x: Sigma A B): B (pr1 A B x)

        .om
            section
                h1 I/O Monads
        section
            p Recursive and Corecursive Monads.

            h2#io IO
            p Finite I/O
            code.
                data IO (A: Type): Type :=
                     (getLine: (String → IO) → IO)
                     (putLine: String → IO → IO)
                     (pure: A → IO)
            p Example:
            code.
                (main: IO.replicateM 100 (IO.>>= IO.data () IO.getLine IO.putLine))

            h2#ioi IOI
            p Infinity I/O
            code.
                data IOI.F (A,State: Type): Type :=
                     (getLine: (String → State) → IO)
                     (putLine: String → State → IO)
                     (pure: A → IO)

                data IOI (A,State: Type) :=
                     (intro: State -> (State -> IOI.F A State) -> IOI)

            p Example:
            code.
                record Main: Type :=
                (main: λ (r: Type) ->
                    IOI.MkIO r (Maybe IOI.data) (Maybe.Nothing IOI.data)
                                ( λ (m: Maybe IOI.data) ->
                                    Maybe.maybe IOI.data m
                                    (IOI.F r (Maybe IOI.data))
                                    ( λ (str: IOI.data) ->
                                        IOI.putLine r (Maybe IOI.data)
                                        str (Maybe.Nothing IOI.data))
                                    (IOI.getLine r (Maybe IOI.data)
                                                (Maybe.Just IOI.data))))
        .om
            section
                h1 Effects
                p Programming effect system with single Monad and Effect Handlers.

        section
            h2#effect Effect
            code.
                record effect (v:Type) (r:Type): Type :=
                       (values: v)
                       (resource: r)
                       (computation: (v → r))
                       (handler: effect v r → monad effect v r)

                data RA: Type          := (intro: effect nat (random nat))
                data IO (t:Type): Type := (intro: effect t   (file t))
                data EX (t:Type): Type := (intro: effect ()  (exception t))

            h2: a(name='eff.monad') Eff.Monad
            code.
                data Eff.Monad (eff: list effect)
                               (m: Type → Type)
                               (a: Type): Type :=
                     (intro: eff m a xs (\ (v: Type) → xs)
                              → monad_eff xs m a)

            h2: a(name='eff.handler') Eff.Handler
            code.
                record Eff.Handler (e: effect)
                                (m: Type → Type): Type :=
                    (action: ∀ (r: res) (eff: e t res resk)
                                (k: ∀ (x: t) → resk x → m a) → m a)

        .om
            section
                h1 Logic
        section
            p Basic Theories: Equality, Congruence, Categories, Setoid.

            h2#path <a name="proto"><a href='proto/'>Proto</a></a>
            code.
                idfun (A: U) (a: A): A
                constfun (A B: U) (a: A) (b: B): A
                o (A B C: U) (f: B -> C) (g: A -> B): A -> C
                and (A B: U): U = (_: A) * B

            h2#path <a name="path"><a href='path/'>Path</a></a>
            code.
                Path (A: U) (a b: A) : U
                sym  (A: U) (a b: A) (p: Path A a b): Path A b a
                refl (A: U) (a: A) : Path A a a
                singl (A: U) (a: A) : U
                trans (A B: U) (p: Path U A B) (a: A) : B
                subst (A: U) (P: A -> U) (a b: A) (p: Path A a b) (e: P a): P b
                mapOnPath (A B: U) (f: A -> B) (a b: A) (p: Path A a b): Path B (f a) (f b)
                composition (A: U) (a b c: A) (p: Path A a b) (q: Path A b c): Path A a c

            h2#cat <a name="propset"><a href='propset/'>Propset</a></a>
            code.
                isContr (A: U): U = (x: A) * ((y: A) -> Path A x y)
                isProp  (A: U): U = n_grpd A Z
                isSet   (A: U): U = n_grpd A (S Z)

            h2#path <a name="equiv"><a href='equiv/'>Equiv</a></a>
            code.
                fiber   (A B: U) (f: A -> B) (y: B): U = (x: A) * Path B y (f x)
                isEquiv (A B: U) (f: A -> B): U = (y: B) -> isContr (fiber A B f y)
                equiv   (A B: U): U = (f: A -> B) * isEquiv A B f

            h2#cat <a name="iso"><a href='iso/'>Iso</a></a>
            code.
                Square (A : U) (a0 a1 b0 b1 : A)
                       (u : Path A a0 a1) (v : Path A b0 b1)
                       (r0 : Path A a0 b0) (r1 : Path A a1 b1) : U

                lemIso (A B : U) (f : A -> B) (g : B -> A)
                       (s : (y : B) -> Path B (f (g y)) y)
                       (t : (x : A) -> Path A (g (f x)) x)
                       (y : B) (x0 x1 : A)
                       (p0 : Path B y (f x0))
                       (p1 : Path B y (f x1)):
                       Path (fiber A B f y) (x0,p0) (x1,p1)

                isoToEquiv (A B: U) (f: A -> B) (g: B -> A)
                       (s: (y: B) -> Path B (f (g y)) y)
                       (t: (x: A) -> Path A (g (f x)) x): isEquiv A B f

                isoPath (A B: U) (f: A -> B) (g: B -> A)
                      (s: (y: B) -> Path B (f (g y)) y)
                      (t: (x: A) -> Path A (g (f x)) x): Path U A B

            h2#cat <a name="cat"><a href='cat/'>Cat</a></a>
            code.
                isPrecategory (C: cat): U
                  = (id: (x: C.1) -> C.2 x x)
                  * (c: (x y z: C.1) -> C.2 x y -> C.2 y z -> C.2 x z)
                  * (homSet: (x y: C.1) -> isSet (C.2 x y))
                  * (left: (x y: C.1) -> (f: C.2 x y) -> Path (C.2 x y) (c x x y (id x) f) f)
                  * (right: (x y: C.1) -> (f: C.2 x y) -> Path (C.2 x y) (c x y y f (id y)) f)
                  * ( (x y z w: C.1) -> (f: C.2 x y) -> (g: C.2 y z) -> (h: C.2 z w) ->
                  Path (C.2 x w) (c x z w (c x y z f g) h) (c x y w f (c y z w g h)))

            h2#setoid Setoid
            p.
                Setoid in essence is a type with an equality.
                Type theory has its own equality type, which could
                be treated as the simplest non-trivial dependent type,
                however the behavior of this kind of equality is
                defined with additional axioms, that may be optional
                in minimal type theory. The neat thing about Setoid
                is that categorical constructions on setoids give
                us equality on all (Co)inductive types, which is
                not dependent on properties of underlying type theory.

            code.
                Setoid (A: U): U
                  = (Carrier: A)
                  * (Equ: (a b: A) -> Path A a b)
                  * (Refl: (x: A) -> Equ x x)
                  * (Trans: (x₁,x₂,x₃: A) -> Equ x₁ x₂ -> Equ x₂ x₃ -> Equ x₁ x₃)
                  * (Sym: (x₁,x₂: A) -> Equ x₁ x₂ -> Equ x₂ x₁)

            h2#groupoid Groupoid
            p.
                <mark>Groupoid</mark> is a multidimensional
                generalization of <mark>Setoid</mark> type,
                which has equalities on equalities and operations
                between them. Gropoid was introduced in algebraїс
                topology for the purposes of homotopy theory and
                has the potential to replace the notion of topological
                space since groupoid covers all the properties of
                topological space from the homotopy perspective.
                The ultimate equality on universum of all types
                was shown in HoTT setting, thus type theory
                became successful for reasoning about homotopies.
                Iterating a Groupoid record over infinity number
                of universes that hold objects and homomorphisms
                gives us a concept of &infin;-Groupoid.

            code.
                inf_grpd (A: U): U
                  = (carrier: A)
                  * (eq: (a b: A) -> Path A a b)
                  * ((a b: A) -> inf_grpd (Path A a b))