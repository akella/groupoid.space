extends ../../layout.pug

block title
    title Types

block content
    +header('../../groupoid.svg', 'Infinity Types', 'Inductive Base Library')
    article.main
        .om
            section
                h1 Article
            aside Maxim Sokhatsky<br>
                time DATE: 20 APR 2018
            p.
                This library is dedicated to <b>cubical</b>-compatible
                typecheckers based on homotopy interval
                <b>[0,1]</b> and MLTT as a core. The base library is founded
                on top of 7 core modules: <b>proto</b> (composition, id, const),
                <b>path</b> (subst, trans, cong, refl, singl, sym),
                <b>prop</b>, <b>set</b>, <b>equiv</b> (fiber, eqiuv)
                and <b>iso</b> (lemIso, isoPath), <b>univ</b>.
                This machinery is enough to prove univalence axiom.
            p.
                Also this library includes:
                (i) Foundation primitives: <b>proto</b>, <b>bool</b>, <b>maybe</b>,
                <b>nat</b>, <b>list</b>, <b>vector</b>, <b>stream</b>.
                (ii) The very basic theorems are given
                in <b>pi</b>, <b>iso_pi</b>, <b>sigma</b>, iso_sigma</b>, <b>retract</b> modules.
                (iii) The library has category theory theorems from
                HoTT book in <b>cat</b>, <b>fun</b>, <b>adj</b>, <b>cones</b>, <b>sip</b> modules.
                (iv) Control Structures in <b>control</b> module.
                (v) Recursive Schemes in <b>recursion</b> module.
                (vi) Abstract Algebra in <b>algebra</b> module.
            p.
                This library is best to read with HoTT book.
        .types
            h2 Base Library Modules
            -
                    var types = {
                        'nr nd +': [ 'unit', 'bool', 'maybe', 'either' ],
                        'r nd +': [ 'nat', 'list' ],
                        'nr d +': [ 'path', 'proto', 'iso', 'equiv' ],
                        'rd +': [ 'vector' ],
                        'nr nd *': [ 'pure', 'functor', 'applicative', 'monad' ],
                        'r nd *': [ 'stream' ],
                        'nr d *': [ 'sigma', 'setoid' ],
                        'rd *': [ 'cat', 'propset', 'groupoid' ]
                    }

                    var legend = {
                        'n': 'Not a',
                        'r': 'Recursive',
                        'd': 'Dependent',
                        '+': 'Coproducts',
                        '*': 'Products'
                    }

            .type
                for v, k in types
                    ol.type__col
                        h3= k.toUpperCase()
                        for i in v
                            li: a(href='#'+i)= i.toUpperCase()
            .legend
                for v, k in legend
                    ul.legend__col
                            li= `${k.toUpperCase()}: ${v}`

        .om
            section
                h1 Martin-Löf Type Theory
        section
            p.
                Martin-Löf Type Theory consist of Pi, Sigma and Equ types.

            h2#pi <a name='pi'><a href='pi/'>Pi</a></a>
            p.
                Pi is a dependent version of a function <b>f: A -> B</b>.
            code.
                Pi (A: U) (P: A -> U): U
            br.
            code.
                id          (A: U): U = A -> A
                idfun       (A: U) (a: A): A = a
                const     (A B: U): U = A
                lam         (A: U) (B: A -> U) (x: A) (b: B(x)): A -> B(x) = \(x: A) -> b
                app         (A: U) (B: A -> U) (x: A) (f: A -> B(x)): B(x) = f(x)
                lambda    (A B: U) (b: B): A -> B = \(_:A) -> b
                apply     (A B: U) (f: A -> B) (x: A): B = f(x)
                funcomp (F G: U -> U) (t: U): U = F (G t)
                ot      (A B C: U): U = (B -> C) -> (A -> B) -> (A -> C)
                o       (A B C: U) (f: B->C) (g: A->B): A -> C = \(x:A) -> f(g(x))
            br.
            code.
                piExt  (A: U) (B: A -> U)
                       (f g: (x:A) -> B x)
                       (p: (x:A) -> Path (B x) (f x) (g x))
                     : Path ((y:A) -> B y) f g
                     = &lt;i&gt; \(a: A) -> (p a) @ i

                funExt (A B: U) (f g: A -> B)
                       (p: (x:A) -> Path B (f x) (g x))
                     : Path (A -> B) f g
                     = &lt;i&gt; \(a: A) -> p a @ i

            h2#sigma <a name='sigma'><a href='sigma/'>Sigma</a></a>
            p.
                Sigma is a generalization or dependent version of Prod.
            code.
                Sigma (A: U) (B: A -> U): U
            br.
            code.
                make (A: U) (B: A -> U) (a: A) (b: B a): Sigma A B
                pr1 (A: U) (B: A -> U) (x: Sigma A B): A
                pr2 (A: U) (B: A -> U) (x: Sigma A B): B (pr1 A B x)
            br.
            code.
                sigRec (A: U) (B: A -> U) (C: U)
                       (g: (x:A) -> B(x) -> C)
                       (p: Sigma A B): C = g p.1 p.2

                sigInd (A: U) (B: A -> U) (C: Sigma A B -> U)
                       (g: (a:A)(b:B(a)) -> C (a,b))
                       (p: Sigma A B): C p = g p.1 p.2

                ac   (A B: U) (R: A -> B -> U):
                     (p: (x:A)->(y:B)*(R x y)) -> (f:A->B)*((x:A)->R(x)(f x))
                  = \(g: (x:A)->(y:B)*(R x y)) -> (\(i:A)->(g i).1,\(j:A)->(g j).2)


            h2#path <a name="path"><a href='path/'>Path</a></a>
            code.
                Path (A: U) (a b: A): U
            br.
            code.
                sym  (A: U) (a b: A) (p: Path A a b): Path A b a
                refl (A: U) (a: A) : Path A a a
                singl (A: U) (a: A) : U
                trans (A B: U) (p: Path U A B) (a: A) : B
                subst (A: U) (P: A -> U) (a b: A) (p: Path A a b) (e: P a): P b
                cong (A B: U) (f: A -> B) (a b: A) (p: Path A a b): Path B (f a) (f b)
                composition (A: U) (a b c: A) (p: Path A a b) (q: Path A b c): Path A a c
                kan (A: U) (a b c d: A) (p: Path A a b) (q: Path A a c) (r: Path A b d): Path A c d
                J (A: U) (a: A) (C: (x: A) -> Path A a x -> U)
                  (d: C a (refl A a)) (x: A) (p: Path A a x): C x p
            br.
            code.
                data N = Z  | S (n: N)

                n_grpd (A: U) (n: N): U = (a b: A) -> ((rec A a b) n) where
                  rec (A: U) (a b: A): (k: N) -> U = split
                      Z -> Path A a b
                      S n -> n_grpd (Path A a b) n

                isContr     (A: U): U = (x: A) * ((y: A) -> Path A x y)
                isProp      (A: U): U = n_grpd A Z
                isSet       (A: U): U = n_grpd A (S Z)
                isGroupoid  (A: U): U = n_grpd A (S (S Z))
                isGrp2      (A: U): U = n_grpd A (S (S (S Z)))
                isGrp3      (A: U): U = n_grpd A (S (S (S (S Z))))
            br.
            code.
                inf_grpd (A: U): U
                  = (carrier: A)
                  * (eq: (a b: A) -> Path A a b)
                  * ((a b: A) -> inf_grpd (Path A a b))

                isInfinityGroupoid (A: U): U = inf_grpd A
            br.
            code.
                PROP         : U = (X:U) * isProp X
                SET          : U = (X:U) * isSet X
                GROUPOID     : U = (X:U) * isGroupoid X
                INF_GROUPOID : U = (X:U) * isInfinityGroupoid X

        .om
            section
                h1 Run-Time Data Types
        section
            p.
                Inductive Types represents polynomial functors
                equiped with recursor and indunction principle.
                Inductive types used for specification the
                evaluation protocol for particular computations.

            h2#empty Empty
            code.
                data empty =
            br.
            code.
                emptyRec (C: U): empty -> C = split {}
                emptyInd (C: empty -> U): (z: empty) -> C z = split {}

            h2#unit Unit
            code.
                data unit = star
            br.
            code.
                unitRec (C: U) (x: C): unit -> C = split tt -> x
                unitInd (C: unit -> U) (x: C tt): (z: unit) -> C z = split tt -> x

            h2#bool <a name='bool'><a href='bool/'>Bool</a></a>
            p.
                <b>bool</b> is run-time version of the boolean logic you
                may use in your general purpose applications.
            code.
                data bool = false | true
            br.
            code.
                b1: U = bool -> bool
                b2: U = bool -> bool -> bool
            br.
            code.
                negation: b1 = split { false -> true ; true -> false }
                or: b2 = split { false -> idfun bool ; true -> lambda bool bool true }
                and: b2 = split { false -> lambda bool bool false ; true -> idfun bool }
            br.
            code.
                boolEq: b2 = lambda bool (bool -> bool) negation
                boolRec (C: U) (f t: C): bool -> C = split { false -> f ; true -> t }
                boolInd (C: bool -> U) (f: A false) (t: A true): (n:bool) -> A n
                      = split { false -> f ; true -> t }

            h2#either Either
            p.
                <b>either</b> is a representation for sum types or disjunction.
            code.
                data either (A B: U) = left (x: A) | right (y: B)
            br.
            code.
                eitherRec (A B C: U) (b: A -> C) (c: B -> C): either A B -> C
                        = split { inl x -> b(x) ; inr y -> c(y) }

                eitherInd (A B: U) (C: either A B -> U)
                          (x: (a: A) -> C (inl a))
                          (y: (b: B) -> C (inr b))
                        : (x: either A B) -> C x
                        = split { inl i -> x i ; inr j -> y j }

            h2#tuple Tuple
            p.
                <b>tuple</b> is a representation for non-dependent
                product types or conjunction.
            code.
                data tuple (A B: U) = pair (x: A) (y: B)
                prod (A B: U) (x: A) (y: B): (_: A) * B = (x,y)
            br.
            code.
                tupleRec  (A B C: U) (c: (x:A) (y:B) -> C): (x: tuple A B) -> C
                        = split pair a b -> c a b
                tupleInd  (A B: U) (C: tuple A B -> U)
                          (c: (x:A)(y:B) -> C (pair x y))
                        : (x: tuple A B) -> C x
                        = split pair a b -> c a b

            h2#maybe <a name='maybe'><a href='maybe/'>Maybe</a></a>
            p.
                Maybe has representing functor M<sub>A</sub>(X) = 1 + A.
                It used for wrapping values with optional nothing constructor.
                In ML-style languages this type is called Option (Miranda, ML).
                There is an <a href="https://raw.githubusercontent.com/groupoid/infinity/master/priv/maybe_nat.ctt">isomorphims</a>
                between <b>(fix maybe)</b> and <b>nat</b>.
            code.
                data maybe (A: U) = nothing | just (x: A)
            br.
            code.
                maybeElim (A B: U) (n: B) (j: A->B): maybe A->B
                        = split { nothing -> n; just a -> j a }

                maybeInd  (A: U) (P: maybe A -> U) (n: P nothing)
                          (j: (a: A) -> P (just a)): (a: maybe A) -> P a
                        = split { nothing -> n ; just x -> j x }

            h2#nat <a name='nat'><a href='nat/'>Nat</a></a>
            p.
                Pointed Unary System is a category nat with the terminal object
                and a carrier <b>nat</b> having morphism <b>[zero:
                1<sub>nat</sub> → nat, succ: nat → nat]</b>. The initial
                object of nat is called Natural Number Object and models
                Peano axiom set.
            code.
                data nat = zero | succ (n: nat)
            br.
            code.
                natEq: nat -> nat -> bool
                natCase (C:U) (a b: C): nat -> C
                natRec  (C:U) (z: C) (s: nat->C->C): (n:nat) -> C
                natElim (C:nat->U) (z: C zero) (s: (n:nat)->C(succ n)): (n:nat) -> C(n)
                natInd  (C:nat->U) (z: C zero) (s: (n:nat)->C(n)->C(succ n)): (n:nat) -> C(n)

            h2#list <a name='list'><a href='list/'>List</a></a>
            p.
                The data type of <b>list</b> over a given set A can
                be represented as the initial algebra (&mu;&nbsp;L<sub>A</sub>,&nbsp;in)
                of the functor L<sub>A</sub>(X) = 1 + (A &times; X).
                Denote &mu; L<sub>A</sub> = List(A). The constructor
                functions nil: 1 &rightarrow; List(A) and cons: A
                &times; List(A) &rightarrow; List(A) are defined
                by nil = in ◦ inl and cons = in ◦ inr, so
                in = <b>[nil,cons]</b>.

            code.
                data list (A: U) = nil | cons (x:A) (xs: list A)
            br.
            code.
                null (A:U): list A −> bool
                head (A:U): list A −> maybe A
                tail (A:U): list A −> maybe (list A)
                nth (A:U): nat −> list A −> maybeA
                append (A: U): list A −> list A −> list A
                reverse (A: U): list A −> list A
                map (A B: U): (A −> B) −> list A −> list B
                zip (AB: U): list A −> list B −> list (tuple A B)
                foldr (AB: U): (A −> B −> B) −> B −> list A −> B
                foldl (AB: U): (B −> A −> B) −> B −> list A −> B
                switch (A: U): (Unit −> list A) −> bool −> list A
                filter (A: U): (A −> bool) −> list A −> list A
                length (A: U): list A −> nat
                listEq (A: eq): list A.1 −> list A.1 −> bool

            h2#stream <a name='stream'><a href='stream/'>Stream</a></a>
            p.
                <b>stream</b> is a record form of the list's
                <b>cons</b> constructor. It models the infinity
                list that has no terminal element.
            code.
                data stream (A: U) = cons (x: A) (xs: stream A)

            h2#vector <a name='vector'><a href='vector/'>Vector</a></a>
            p.
                <b>vector</b> is the inductive defintion of limited length list.
                Through it depends on term <b>nat</b> it can be used on reasoning
                about single discrete dimention of the space, bringing very
                basic inductive logic. It can be used for reasoning about
                <b>sqrt</b>, as latter for any fractional exponent has
                correspondent number of roots inscribed in a circle on
                a complex surface. When vector is not dependent on nat
                its encoding should match with regular <b>list</b>.
            code.
                data vector (A: U) (n: nat)
                   = nil
                   | cons (x: A) (xs: vector A (pred n))

            h2#proto <a name="proto"><a href='proto/'>Proto</a></a>
            code.
                idfun (A: U) (a: A): A
                const (A B: U) (a: A) (b: B): A
                o (A B C: U) (f: B -> C) (g: A -> B): A -> C
                prod (A B: U): U = (_: A) * B
        .om
            section
                h1 Control Structures

            h2#applicative Fix, Mu, Nu
            code.
                data fix    (F: U -> U) = Fix (point: F (fix F))
                data mu     (F: U -> U) (A B: U)  = ReturnF (a: A) | BindF (f: F B)
                data nu     (F: U -> U) (A B: U)  = CoBindF (a: A)         (f: F B)
                data free   (F: U -> U) (A: U)    = Free    (_: fix (mu        F A))
                data cofree (F: U -> U) (A: U)    = CoFree  (_: fix (nu        F A))

            h2#signature Signatures
            code.
                pure_sig       (F:U->U):U=   (A: U) ->           A  -> F A
                extract_sig    (F:U->U):U=   (A: U) ->         F A  ->   A
                extend_sig     (F:U->U):U= (A B: U) ->   (F A -> B) -> F A -> F B
                appl_sig       (F:U->U):U= (A B: U) ->   F (A -> B) -> F A -> F B
                fmap_sig       (F:U->U):U= (A B: U) ->     (A -> B) -> F A -> F B
                unmap_sig      (F:U->U):U= (A B: U) -> (F A -> F B) ->  (A -> B)
                contra_sig     (F:U->U):U= (A B: U) ->     (B -> A) -> F A -> F B
                uncontra_sig   (F:U->U):U= (A B: U) -> (F A -> F B) ->  (B -> A)
                cofmap_sig     (F:U->U):U= (A B: U) ->     (B -> A) -> F B -> F A
                uncofmap_sig   (F:U->U):U= (A B: U) -> (F B -> F A) ->  (B -> A)
                cocontra_sig   (F:U->U):U= (A B: U) ->     (A -> B) -> F B -> F A
                uncocontra_sig (F:U->U):U= (A B: U) -> (F B -> F A) ->  (A -> B)
                join_sig       (F:U->U):U=   (A: U) ->      F (F A) -> F A
                dup_sig        (F:U->U):U=   (A: U) ->         F A  -> F (F A)
                bind_sig       (F:U->U):U= (A B: U) ->    F A ->(A  -> F B)-> F B

            h2#signature Carriers
            code.

                pure:        U = (F: U -> U) * pure_sig F
                functor:     U = (F: U -> U) * fmap_sig F

                applicative: U = (F: U -> U)
                               * (_: pure_sig F)
                               * (_: fmap_sig F)
                               *     appl_sig F

                monad:       U = (F: U -> U)
                               * (_: pure_sig F)
                               * (_: fmap_sig F)
                               * (_: appl_sig F)
                               *     bind_sig F

            h2#functor Functor
            code.
                isFunctor (F: functor): U
                  = (id: (A: U) -> (x: F.1 A) ->
                     Path (F.1 A) (fmap F A A (idfun A) x) x)
                  * (compose: (A B C: U) (f: B -> C) (g: A -> B) (x: F.1 A) ->
                              Path (F.1 C) (F.2 A C (o A B C f g) x)
                                   ((o (F.1 A) (F.1 B) (F.1 C)
                                       (F.2 B C f) (F.2 A B g)) x)) * unit

            h2#applicative Applicative
            code.
                isApplicative (F: applicative): U
                    = (id:  (A:U) -> (x: F.1 A) ->
                       Path (F.1 A) x (ap F A A (apure F (id A) (idfun A)) x))
                    * (hom: (A B:U)(f:A->B)(x: A) ->
                       Path (F.1 B) (apure F B (f x)) (ap F A B (apure F (A->B) f) (apure F A x)))
                    * (cmp: (A B C:U)(v: F.1(A->B))(u:F.1(B->C))(w:F.1 A) ->
                       Path (F.1 C) (ap F B C u (ap F A B v w))
                                    (ap F A C (ap F (A->B) (A->C) (ap F(B->C)((A->B)->(A->C))
                                    (apure F (ot A B C) (o A B C)) u) v) w))
                    * (xchg: (A B:U)(x:A)(u:F.1(A->B))(f:A->B) ->
                       Path (F.1 B) (ap F A B u ((apure F) A x))
                                    (ap F (A->B) B (apure F ((A->B)->B) (\(f:A->B)->f(x))) u)) * unit

            h2#monad Monad
            code.
                isMonad (F: monad): U
                    = (left_id:  (A B:U)(f:A->F.1 B)(x:A) ->
                                 Path (F.1 B) (bind F A B (mpure F A x) f) (f x))
                    * (right_id: (A:U) (m: F.1 A) ->
                                 Path (F.1 A) (bind F A A m (mpure F A)) m)
                    * (assoc: (A B C: U) (f: A -> F.1 B) (g: B -> F.1 C) (m: F.1 A) ->
                       Path (F.1 C) (bind F B C (bind F A B m f) g)
                                    (bind F A C m (\(x: A) -> bind F B C (f x) g))) * unit
            br.
            code.
                FUNCTOR:     U = (f: functor)
                               * isFunctor f

                APPLICATIVE: U = (f: applicative)
                               * (_: isFunctor (f.1,f.2.2.1))
                               * isApplicative f

                MONAD:       U = (f: monad)
                               * (_: isFunctor (f.1,f.2.2.1))
                               * (_: isApplicative (f.1,f.2.1,f.2.2.1,f.2.2.2.1))
                               * isMonad f

        .om
            section
                h1 Logic
        section

            h2#setoid Setoid
            p.
                Setoid in essence is a type with an equality.
                Type theory has its own equality type, which could
                be treated as the simplest non-trivial dependent type,
                however the behavior of this kind of equality is
                defined with additional axioms, that may be optional
                in minimal type theory. The neat thing about Setoid
                is that categorical constructions on setoids give
                us equality on all (Co)inductive types, which is
                not dependent on properties of underlying type theory.

            code.
                Setoid (A: U): U
                  = (Carrier: A)
                  * (Equ: (a b: A) -> Path A a b)
                  * (Refl: (x: A) -> Equ x x)
                  * (Trans: (x₁,x₂,x₃: A) -> Equ x₁ x₂ -> Equ x₂ x₃ -> Equ x₁ x₃)
                  * (Sym: (x₁,x₂: A) -> Equ x₁ x₂ -> Equ x₂ x₁)

            h2#equiv <a name="equiv"><a href='equiv/'>Equiv</a></a>
            code.
                fiber   (A B: U) (f: A -> B) (y: B): U = (x: A) * Path B y (f x)
                isEquiv (A B: U) (f: A -> B): U = (y: B) -> isContr (fiber A B f y)
                equiv   (A B: U): U = (f: A -> B) * isEquiv A B f

            h2#iso <a name="iso"><a href='iso/'>Iso</a></a>
            code.
                Square (A : U) (a0 a1 b0 b1 : A)
                       (u : Path A a0 a1) (v : Path A b0 b1)
                       (r0 : Path A a0 b0) (r1 : Path A a1 b1) : U

                lemIso (A B : U) (f : A -> B) (g : B -> A)
                       (s : (y : B) -> Path B (f (g y)) y)
                       (t : (x : A) -> Path A (g (f x)) x)
                       (y : B) (x0 x1 : A)
                       (p0 : Path B y (f x0))
                       (p1 : Path B y (f x1)):
                       Path (fiber A B f y) (x0,p0) (x1,p1)

                isoToEquiv (A B: U) (f: A -> B) (g: B -> A)
                       (s: (y: B) -> Path B (f (g y)) y)
                       (t: (x: A) -> Path A (g (f x)) x): isEquiv A B f

                isoPath (A B: U) (f: A -> B) (g: B -> A)
                      (s: (y: B) -> Path B (f (g y)) y)
                      (t: (x: A) -> Path A (g (f x)) x): Path U A B


            h2#groupoid Groupoid
            p.
                <b>Groupoid</b> is a multidimensional
                generalization of <b>Setoid</b> type,
                which has equalities on equalities and operations
                between them. Gropoid was introduced in algebraїс
                topology for the purposes of homotopy theory and
                has the potential to replace the notion of topological
                space since groupoid covers all the properties of
                topological space from the homotopy perspective.
                The ultimate equality on universum of all types
                was shown in HoTT setting, thus type theory
                became successful for reasoning about homotopies.
                Iterating a Groupoid record over infinity number
                of universes that hold objects and homomorphisms
                gives us a concept of &infin;-Groupoid.

            code.
                inf_grpd (A: U): U
                  = (carrier: A)
                  * (eq: (a b: A) -> Path A a b)
                  * ((a b: A) -> inf_grpd (Path A a b))
        .om
            section
                h1 Abstract Algebra
        section

            h2#cat <a name="monoid"><a href='monoid/'>Monoid</a></a>
            code.

        .om
            section
                h1 Category Theory
        section

            h2#cat <a name="cat"><a href='cat/'>Cat</a></a>
            code.
                isPrecategory (C: cat): U
                  = (id: (x: C.1) -> C.2 x x)
                  * (c: (x y z: C.1) -> C.2 x y -> C.2 y z -> C.2 x z)
                  * (homSet: (x y: C.1) -> isSet (C.2 x y))
                  * (left: (x y: C.1) -> (f: C.2 x y) -> Path (C.2 x y) (c x x y (id x) f) f)
                  * (right: (x y: C.1) -> (f: C.2 x y) -> Path (C.2 x y) (c x y y f (id y)) f)
                  * ( (x y z w: C.1) -> (f: C.2 x y) -> (g: C.2 y z) -> (h: C.2 z w) ->
                  Path (C.2 x w) (c x z w (c x y z f g) h) (c x y w f (c y z w g h)))
