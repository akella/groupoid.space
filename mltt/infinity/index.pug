extends ../../layout.pug

block title
    title INFINITY

block content
    +header('//groupoid.space/groupoid.svg', 'Infinity Language', 'MLTT Extensions')
    article.main
        .exe
            section

                h2 Introduction
                p.
                    The idea of Infinity Langauge came from the needs of unification and
                    arranging different calculuses as an extensions to the core of the
                    language with dependent types (or MLTT core). While been working on
                    distributed systems, data storages and stream processing, the core
                    two languages: pi calculus and stream calculus discovered to be
                    connected and being driven by a language with quantifiers as a primitives.
                    So we started to look forward for unificated typechecker.

                h2 Pure Type System
                p.
                    From the time Coquand at all discovered Calculus of Constructions,
                    and Barendregt systemized its variations, a Pure Type System theory
                    was developed. It is known also as Single Axiom System with
                    only Pi-Type of MLTT, represeting Functional Complentess.
                code.
                    data O<sub>1</sub> = U : nat → O<sub>1</sub>
                            | Var: Ident → O<sub>1</sub>
                            | App: O<sub>1</sub> → O<sub>1</sub> → O<sub>1</sub>
                            | Lambda: Binder → O<sub>1</sub> → O<sub>1</sub> → O<sub>1</sub>
                            | Arrow: O<sub>1</sub> → O<sub>1</sub> → O<sub>1</sub>
                            | Pi: name → O<sub>1</sub> → O<sub>1</sub> → O<sub>1</sub>

                h2 Contextual Completness
                p.
                    The basic Core primitive whish is needed for proving things
                    is MLTT Sigma-Type, representing Contextual Completness. This
                    is needed for building Sigma pairs, the carrier for the
                    carried records. Usually type checkers called Pi-Sigma provers as
                    it contains PTS encriched with Sigma primitive.
                code.
                    data O<sub>2</sub> = O<sub>1</sub>
                            | Sigma: name → O<sub>2</sub> → O<sub>2</sub> → O<sub>2</sub>
                            | Pair: O<sub>2</sub> → O<sub>2</sub> → O<sub>2</sub>
                            | Fst: O<sub>2</sub> → O<sub>2</sub>
                            | Snd: O<sub>2</sub> → O<sub>2</sub>

                h2 (Co)-Inductive Types
                p.
                    The further development of induction inside MLTT provers led to
                    theory of polynomial functors and well founded trees, known in
                    programming languages as inductive types with <mark>data</mark>
                    and <mark>record</mark> core primitives of type checker.

                h2 Higher Inductive Types
                p.
                    The fundamental development of equality inside MLTT provers
                    led us to notion of ∞-groupoid as spaces. In this was
                    Path identity type appeared in the core of type checker along
                    with de Morgan algebra on built-in interval type. Glue, unglue
                    composition and fill operations are also needed in the core for
                    the univalence computability.

            section.langf
                .langf__col
                    h2#syntax Language Extensions
                    code.
                        Require Import core.
                        Require Import homotopy.
                        Require Import pi.
                        Require Import stream.
                        Require Import effect.

                        Inductive MLTT := Pi:     MLTT   -> MLTT -> MLTT
                                        | Lam:    Binder -> MLTT -> MLTT
                                        | App:    MLTT   -> MLTT -> MLTT
                                        | Sigma:  MLTT   -> MLTT -> MLTT
                                        | Pair:   MLTT   -> MLTT -> MLTT
                                        | Fst:    MLTT   -> MLTT
                                        | Snd:    MLTT   -> MLTT
                                        | Where:  MLTT   -> Decls -> MLTT
                                        | Var:    Ident  -> MLTT
                                        | U:      MLTT
                                        | Con:    Label  -> list MLTT   -> MLTT
                                        | Split:  Loc    -> list Branch -> MLTT
                                        | Sum:    Binder -> NamedSum    -> MLTT
                                        | HIT:    HomotopyCalculus -> MLTT
                                        | PI:     PiCalculus       -> MLTT
                                        | EFF:    EffectCalculus   -> MLTT
                                        | STREAM: StreamCalculus   -> MLTT.

                    h2#passes Compiler Passes
                    ol
                        li <a href='#macro'>INF</a> &mdash; Macro Expansion
                        li <a href='../om/#normal'>NORMAL</a> &mdash; Typechecking
                        li <a href='../om/#erased'>ERASE</a> &mdash; Type Information Erasure
                        li <a href='../om/#extract'>EXTRACT</a> &mdash; Extract VM Lambda

            section
                h1 Calculus
                p.
                    The type system is completely described by the PTS SAR notation, given by Barendregt.
                    Find more info in <a href='../om/#axioms'>Axioms and Inference Rules</a>
                    of underlying Om intermediate language.
                code.
                    record PTS: * :=
                           (S: ∀ (n: nat) → star n)
                           (A: ∀ (i: nat) → type i (succ i))
                           (R: ∀ (i: nat) → ∀ (j: nat)
                                          → pi i j (max i j))

            section
                h1 Macrosystem
                .macro
                    .macro__col
                        h3#om Om
                        ol
                            li: a(href='#function') LAMBDA
                            li: a(href='#function') PI
                            li: a(href='#application') APP
                            li: a(href='#var') VAR
                            li: a(href='#star') STAR
                    .macro__col
                        h3#macro Macro
                        ol
                            li: a(href='#data') DATA
                            li: a(href='#record') RECORD
                            li: a(href='#let') LET
                            li: a(href='#case') CASE
                    .macro__col
                        ol
                            h3#eff Effects
                            li: a(href='#process') SPAWN
                            li: a(href='#send') SEND
                            li: a(href='#receive') RECEIVE
                            li: a(href='#try') TRY
                            li: a(href='#raise') RAISE
                            li: a(href='#raise') DO

            section
                h2#om Om
                p.
                    <mark>Om</mark> language is the macrosystem terminal language.
                    Language forms of pure <mark>Macro</mark> or inpure <mark>Effect</mark>
                    types are expanded to the terminal language. For the details please refer to the <a href='/om'>Om Assembler</a> description.
                code.
                    data Om: * :=
                         (star: Star → Om)
                         (var: Var → Om)
                         (app: App → Om)
                         (arrow: Arrow → Om)
                         (pi: Pi → Om)

                h2#star Star
                code.
                    record Star: * :=
                           (index: nat)

                h2#var Variable
                code.
                    record Var: * :=
                           (name: string)

                h2#function Arrow / Pi
                code.
                    record Arrow Pi: * :=
                           (name: string)
                           (arg: Om)
                           (body: Om)

                h2#application Application
                code.
                    record App: * :=
                           (fun: Om)
                           (arg: Om)

                h2#macro Macro
                p.
                    <mark>Macro</mark> language subsystem is the core of Inf language and dedicated to compile the prelude desceibed in the <a href='/types'>Core Types</a> document. Om language is the target language of macroexpansions of <mark>data</mark> and <mark>record</mark> inductive constructions, <mark>let</mark> construction and univariable <mark>case</mark> pattern matching.
                code.
                    data Macro: * :=
                         (record: Record → Macro)
                         (data: Data → Macro)
                         (let: Let → Macro)
                         (case: Case → Macro)

                h2#case Case / Receive
                code.
                    record Case Receive: * :=
                           (of: Inf)
                           (legs: list (prod atom (prod Om Inf)))
                           (default: Inf)

                h2#let Let
                code.
                    record Let: * :=
                           (binds: list (prod string Inf))
                           (in: Inf)

                h2 <a name="data"><a name="record">Record / Data</a></a>
                code.
                    record Record Data: * :=
                           (name: string)
                           (base: Om)
                           (body: list (prod string Inf))

                h2#eff Effect
                p.
                    <mark>Effect</mark> syntax extensions defined basic process calculus axioms, IO and exception handling.
                code.
                    data Effect: * :=
                         (receive: Receive → Effect)
                         (spawn: Spawn → Effect)
                         (send: Send → Effect)
                         (try: Exception → Effect)
                         (raise: Exception → Effect)
                         (write: File → Effect)
                         (read: File → Effect)

                h2#process Process
                code.
                    record Process: (Sigma: *) → (X: *) → * :=
                           (action: Sigma → X → GenServer X)

                h2#spawn Spawn
                code.
                    record Spawn:
                           (proc: Process)
                           (raise: list Eff)

                h2#send Send
                code.
                    record Send: (Sigma: *) → * :=
                           (message: Sigma)
                           (to: Process Sigma)


