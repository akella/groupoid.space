extends ../../layout.pug

block title
    title INFINITY

block content
    +header('//groupoid.space/groupoid.svg', 'Infinity Language', 'MLTT Extensions')
    article.main
        .exe
            section

                h2 Introduction
                p.
                    The idea of Infinity Langauge came from the needs of unification and
                    arranging different calculuses as extensions to the core of the language
                    with dependent types (or MLTT core). While been working on distributed
                    systems, data storages and stream processing, the core two languages:
                    pi-calculus and stream calculus discovered to be connected and being
                    driven by a language with quantifiers as primitives. So we started
                    to look forward to a unified type checker.

                h2 Pure Type System
                p.
                    From the time Coquand at all discovered Calculus of Constructions,
                    and Barendregt systemized its variations, a Pure Type System
                    theory was developed. It is known also as Single Axiom System
                    with only Pi-Type of MLTT, representing Functional Completeness.
                code.
                    data O<sub>1</sub> = U : nat → O<sub>1</sub>
                            | Var: Ident → O<sub>1</sub>
                            | App: O<sub>1</sub> → O<sub>1</sub> → O<sub>1</sub>
                            | Lambda: Binder → O<sub>1</sub> → O<sub>1</sub> → O<sub>1</sub>
                            | Arrow: O<sub>1</sub> → O<sub>1</sub> → O<sub>1</sub>
                            | Pi: name → O<sub>1</sub> → O<sub>1</sub> → O<sub>1</sub>

                h2 Contextual Completness
                p.
                    The basic Core primitive which is needed for proving things
                    is MLTT Sigma-Type, representing Contextual Completeness.
                    This is needed for building Sigma pairs which are curried
                    records. Usually, type checkers called Pi-Sigma provers
                    as it contains PTS enriched with Sigma primitive.
                code.
                    data O<sub>2</sub> = O<sub>1</sub>
                            | Sigma: name → O<sub>2</sub> → O<sub>2</sub> → O<sub>2</sub>
                            | Pair: O<sub>2</sub> → O<sub>2</sub> → O<sub>2</sub>
                            | Fst: O<sub>2</sub> → O<sub>2</sub>
                            | Snd: O<sub>2</sub> → O<sub>2</sub>

                h2 (Co)-Inductive Types
                p.
                    The further development of induction inside MLTT provers led to
                    theory of polynomial functors and well founded trees, known in
                    programming languages as inductive types with <mark>data</mark>
                    and <mark>record</mark> core primitives of type checker.
                code.
                    data O<sub>3</sub> = O<sub>2</sub>
                            | Id: O<sub>3</sub> → O<sub>3</sub> → O<sub>3</sub>
                            | IdPair: O<sub>3</sub> → O<sub>3</sub> → O<sub>3</sub>
                            | IdJ: O<sub>3</sub> → O<sub>3</sub> → O<sub>3</sub> → O<sub>3</sub> → O<sub>3</sub> → O<sub>3</sub>
                            | Sum: tele → list Branch → O<sub>3</sub>
                            | Split: name → list Branch → O<sub>3</sub>
                            | Ctor: name → list O<sub>3</sub> → O<sub>3</sub>

                h2 Higher Inductive Types
                p.
                    The fundamental development of equality inside MLTT provers
                    led us to notion of ∞-groupoid as spaces. In this was
                    Path identity type appeared in the core of type checker along
                    with de Morgan algebra on built-in interval type. Glue, unglue
                    composition and fill operations are also needed in the core for
                    the univalence computability.
                code.
                    data O<sub>4</sub> = O<sub>3</sub>
                            | Path: O<sub>4</sub> → O<sub>4</sub> → O<sub>4</sub>
                            | PathLam: Binder → O<sub>4</sub> → O<sub>4</sub> → O<sub>4</sub>
                            | PathApp: O<sub>4</sub> → Formula → O<sub>4</sub> → O<sub>4</sub>
                            | Comp: O<sub>4</sub> → O<sub>4</sub> → O<sub>4</sub>
                            | Fill: O<sub>4</sub> → O<sub>4</sub> → O<sub>4</sub>
                            | Glue: O<sub>4</sub> → O<sub>4</sub> → O<sub>4</sub>
                            | GlueElem: O<sub>4</sub> → O<sub>4</sub> → O<sub>4</sub>
                            | UnGlueElem: O<sub>4</sub> → O<sub>4</sub> → O<sub>4</sub>

            section
                h2 Universes
                p.
                    The universe system is completely described by the PTS SAR notation,
                    given by Barendregt. Find more info in
                    <a href='../pure/#axioms'>Axioms and Inference Rules</a>
                    of underlying Om intermediate language.
                code.
                    record PTS: * :=
                           (S: ∀ (n: nat) → star n)
                           (A: ∀ (i: nat) → type i (succ i))
                           (R: ∀ (i: nat) → ∀ (j: nat)
                                          → pi i j (max i j))

