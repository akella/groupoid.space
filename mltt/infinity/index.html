<!DOCTYPE html><html><head><meta charset="utf-8"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="author" content="Maxim Sokhatsky"><meta name="twitter:card" content="summary"><meta name="twitter:site" content="@5HT"><meta name="twitter:creator" content="@5HT"><meta name="twitter:image" content="https://groupoid.space/grp.png"><meta property="og:title" content="Groupoid Infinity"><meta property="og:image" content="https://groupoid.space/grp.png"><meta property="og:type" content="website"><meta property="fb:app_id" content="118554188236439"><meta property="og:url" content="https://groupoid.space"><meta property="og:description" content="Dependent Types"><link rel="stylesheet" href="//groupoid.space/main.css"><title>INFINITY</title></head><body class="content"><header class="header"><a href="//groupoid.space/"><img class="header__logo" src="//groupoid.space/groupoid.svg"/></a><div class="header__titles"><h1 class="header__title">Infinity Language</h1><h4 class="header__subtitle">MLTT Extensions</h4></div></header><article class="main"><div class="exe"><section><h2>Introduction</h2><p>The idea of Infinity Langauge came from the needs of unification and
arranging different calculuses as extensions to the core of the language
with dependent types (or MLTT core). While been working on distributed
systems, data storages and stream processing, the core two languages:
pi-calculus and stream calculus discovered to be connected and being
driven by a language with quantifiers as primitives. So we started
to look forward to a unified type checker.
</p><h2>Pure Type System</h2><p>From the time Coquand at all discovered Calculus of Constructions<sup>6</sup>,
and Barendregt<sup>7</sup> systemized its variations, a Pure Type System
theory was developed. It is known also as Single Axiom System
with only Pi-Type of MLTT<sup>2</sup>, representing Functional Completeness<sup>3</sup>.</p><code>data O<sub>1</sub> = U : nat → O<sub>1</sub>
        | Var: Ident → O<sub>1</sub>
        | App: O<sub>1</sub> → O<sub>1</sub> → O<sub>1</sub>
        | Lambda: Binder → O<sub>1</sub> → O<sub>1</sub> → O<sub>1</sub>
        | Arrow: O<sub>1</sub> → O<sub>1</sub> → O<sub>1</sub>
        | Pi: name → O<sub>1</sub> → O<sub>1</sub> → O<sub>1</sub>
</code><p>1. S.MacLane. Categories for the Working Mathematician<br>
2. P.Martin-Löf. An Intuitionistic Theory of Types. 1972  <br>
3. N.Jacobs. Fibrations with indeterminates. 1994 <br>
4. W.Lawvere. Conceptual Mathematics. 1997  <br>
5. P.Curien. Category theory: a programming language-oriented introduction. 2008  <br>
6. T.Coquand. The Calculus of Constructions. 1988 <br>
7. H.Barendregt. Lambda Calculus With Types. 2010 <br>
</p><h2>Contextual Completness</h2><p>The basic Core primitive which is needed for proving things
is MLTT Sigma-Type, representing Contextual Completeness.
This is needed for building Sigma pairs which are curried
records. Usually, type checkers called Pi-Sigma provers
as it contains PTS enriched with Sigma primitive.</p><code>data O<sub>2</sub> = O<sub>1</sub>
        | Sigma: name → O<sub>2</sub> → O<sub>2</sub> → O<sub>2</sub>
        | Pair: O<sub>2</sub> → O<sub>2</sub> → O<sub>2</sub>
        | Fst: O<sub>2</sub> → O<sub>2</sub>
        | Snd: O<sub>2</sub> → O<sub>2</sub>
</code><h2>(Co)-Inductive Types</h2><p>The further development of induction inside MLTT provers led
to the theory of polynomial functors and well-founded trees,
known in programming languages as inductive types with data
and record core primitives of type checker.</p><code>data O<sub>3</sub> = O<sub>2</sub>
        | Id: O<sub>3</sub> → O<sub>3</sub> → O<sub>3</sub>
        | IdPair: O<sub>3</sub> → O<sub>3</sub> → O<sub>3</sub>
        | IdJ: O<sub>3</sub> → O<sub>3</sub> → O<sub>3</sub> → O<sub>3</sub> → O<sub>3</sub> → O<sub>3</sub>
        | Sum: tele → list Branch → O<sub>3</sub>
        | Split: name → list Branch → O<sub>3</sub>
        | Ctor: name → list O<sub>3</sub> → O<sub>3</sub>
</code><h2>Higher Inductive Types</h2><p>The fundamental development of equality inside MLTT
provers led us to the notion of ∞-groupoid as spaces.
In this was Path identity type appeared in the core
of type checker along with de Morgan algebra on
built-in interval type. Glue, unglue composition
and fill operations are also needed in the core
for the univalence computability.</p><code>data O<sub>4</sub> = O<sub>3</sub>
        | Path: O<sub>4</sub> → O<sub>4</sub> → O<sub>4</sub>
        | PathLam: Binder → O<sub>4</sub> → O<sub>4</sub> → O<sub>4</sub>
        | PathApp: O<sub>4</sub> → Formula → O<sub>4</sub> → O<sub>4</sub>
        | Comp: O<sub>4</sub> → O<sub>4</sub> → O<sub>4</sub>
        | Fill: O<sub>4</sub> → O<sub>4</sub> → O<sub>4</sub>
        | Glue: O<sub>4</sub> → O<sub>4</sub> → O<sub>4</sub>
        | GlueElem: O<sub>4</sub> → O<sub>4</sub> → O<sub>4</sub>
        | UnGlueElem: O<sub>4</sub> → O<sub>4</sub> → O<sub>4</sub>
</code></section><section><h2>Universes</h2><p>The universe system is completely described by the PTS SAR notation,
given by Barendregt. Find more info in
<a href='../pure/#axioms'>Axioms and Inference Rules</a>
of underlying Om intermediate language.</p><code>record PTS: * :=
       (S: ∀ (n: nat) → star n)
       (A: ∀ (i: nat) → type i (succ i))
       (R: ∀ (i: nat) → ∀ (j: nat)
                      → pi i j (max i j))</code></section></div></article><footer class="footer"><img class="footer__logo" src="https://longchenpa.guru/seal.png" width="50"><span class="footer__copy">2016&mdash;2017 &copy; Groupoid Infinity</span></footer><script src="//groupoid.space/bundle.js"></script><script src="//groupoid.space/highlight.js"></script></body></html>