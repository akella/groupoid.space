extends ../../layout.pug

block title
    title OM

block content
    +header('http://groupoid.space/groupoid.svg', 'Single Axiom Language', 'OM &mdash; language with universal quntifier and infinity number of universes for typechecking and normalization')
    article.main
        .om
            section
                h1 Definition

                h2#nat Pure Type System
                p.
                    The <mark>OM</mark> language is a dependently typed lambda calculus,
                    an extension of Barendregt' and Coquand Calculus of Constructions
                    with the predicative hierarchy of indexed universes.
                    There is no fixpoint axiom needed for the definition of infinity term dependance.
                code.
                    U₀ : U₁ : U₂ : U₃ : …

                    U₀ — propositions
                    U₁ — values and sets
                    U₂ — types
                    U₃ — sorts

                h2#axioms Axioms and Inference Rules
                p.
                    All terms obey the <mark>A</mark> ranking inside the sequence of <mark>S</mark> universes,
                    and the complexity <mark>R</mark> of the dependent term is equal to a maximum of
                    the term's complexity and its dependency.
                    The type system is completely described by the following PTS notation (due to Barendregt):
                code.
                    S    (n : nat) = U n
                    A₁   (n : nat) = U n : U (n + 1) — non-cumulative
                    R₁ (m n : nat) = U m ⟶ U n : U (max m n) — predicative

                h2#axioms Supported Configuration
                p.
                    Propositional contractible bottom space is impredicative by derm dependance.
                code.
                    A₂ (n m : nat) = U n : U m where m > n — cumulative
                    R₂ (m n : nat) = U m ⟶ U n : U n — impredicative

                h2#syntax Extract Language
                p.
                    The untyped lambda language O is the simplest language used in
                    OM to generate backend programs. This O is used as the output of type erasure.
                code.
                    I = #identifier
                    T = I | ( T ) | T T | λ I ⟶ T
                p.
                    The terms of OM consist of NN-indexed stars, variables, applications,
                    lambda-abstractions and universal quantifications (Pi-types).
                    This language is called Calculus of Construction and exists in various syntaxes.
                    OM supports Morte's syntax.
                code.
                    <> = #option
                    I  = #identifier
                    U  = * < #number >
                    O  = U | I | ( O ) | λ ( I : O ) → O
                           O O | O → O | ∀ ( I : O ) → O


                h2#ast Type System a la Martin-Löf
                p.
                    This langauge is called one axiom language as it reduction
                    rule is inferred from type formation axiom along with eliminator
                    and introduction adjoint functors.
                code.
                    ∀ x: A → B x : Type              — formation rule
                    λ x: A → b : B x                 — introduction
                    app f a : B x                    — elimination
                    app (λ a:A, b) a = b [p/a] : B x — equation
                p.
                    This language could be embedded in itself and used as Logical Framework.
                code.
                    Record Pi (A: Type) :=
                           intro: (A → Type) → Type
                           fun: (B: A → Type) → ∀ (a: A) → B a → intro B
                           app: (B: A → Type) → intro B → ∀ (a: A) → B a
                           app-fun (B: A → Type) (f: ∀ (a: A) → B a): ∀ (a: A) → app (fun f) a ==> f a
                           fun-app (B: A → Type) (p: intro B): fun (λ (a: A) → app p a) ==> p

                h2#ast AST
                code.
                    Inductive OM := Star: nat → OM)
                                  | Var: name → OM)
                                  | App: OM → OM → OM)
                                  | Lambda: name → OM → OM → OM)    
                                  | Arrow: OM → OM → OM)
                                  | Pi: name → OM → OM → OM)

                h2#typechecker Typechecker
                h3 Type
                code.
                    type (Star n)         D : Star n + 1

                    type (Var n)          D : let _ = isVar n D
                                              in nth (i + 1) (all n D)

                    type (Arrow i o)      D : Star max (star (type i D))
                                                       (star (type o D))

                    type (Pi n 0 i o)     D : Star max (star (type i D))
                                                       (star (type o [(n norm i)|D]))

                    type (Lambda n 0 i o) D : let _ = star (type i D) in
                                              let ni = norm i in
                                              Pi n 0 ni (type O [(n ni)|D])

                    type (App f a)        D : let t = type f D in
                                              let _ = isFun t in
                                              match t
                                               | Pi n 0 i o => let _ = eq i (type a D)
                                                               in norm (subst o n a)
            section
                h1 Passes

                h2#normal Normalized
                p Terms in OM language.
                code.
                    $ om show List/Cons

                    λ (A: *)
                    → λ (Head: A)
                    → λ (Tail:
                        ∀ (List: *)
                    → ∀ (Cons:
                        ∀ (Head: A)
                        → ∀ (Tail: List)
                        → List)
                    → ∀ (Nil: List)
                    → List)
                    → λ (List: *)
                    → λ (Cons:
                        ∀ (Head: A)
                    → ∀ (Tail: List)
                    → List)
                    → λ (Nil: List)
                    → Cons Head (Tail List Cons Nil)

                    {{"λ",{'A',0}},
                    {{star,1},
                    {{"λ",{'Head',0}},
                    {{var,{'A',0}},
                        {{"λ",{'Tail',0}},
                        {{{"∀",{'List',0}},
                        {{star,1},
                            {{"∀",{'Cons',0}},
                            {{{"∀",{'Head',0}},
                            {{var,{'A',0}},
                                {{"∀",{'Tail',0}},
                                {{var,{'List',0}},{var,{'List',0}}}}}},
                            {{"∀",{'Nil',0}},
                            {{var,{'List',0}},{var,{'List',0}}}}}}}},
                        {{"λ",{'List',0}},
                        {{star,1},
                            {{"λ",{'Cons',0}},
                            {{{"∀",{'Head',0}},
                            {{var,{'A',0}},
                                {{"∀",{'Tail',0}},
                                {{var,{'List',0}},{var,{'List',0}}}}}},
                            {{"λ",{'Nil',0}},
                            {{var,{'List',0}},
                                {app,{{app,{{var,{'Cons',0}},
                                            {var,{'Head',0}}}},
                                    {app,{{app,{{app,{{var,{'Tail',0}},
                                                        {var,{'List',0}}}},
                                                {var,{'Cons',0}}}},
                                            {var,{'Nil',0}}}}}}}}}}}}}}}}}}


                h2#erased Erased
                p Terms in untyped lambda pure language.
                code.
                    $ om print fst erase a "#List/Cons"
                    ( λ Head
                    → ( λ Tail
                    → ( λ Cons
                    → ( λ Nil
                    → ((Cons Head) ((Tail Cons) Nil))))))
                    ok

                h2#extract Extract
                p.
                    Erlang extracted code. For other targets you may want to read
                    <a href='/extract'> Code Extract</a> notes.
                code.
                    'Cons'() -> fun (Head) -> fun (Tail) -> fun (Cons) -> fun (Nil) ->
                        ((Cons(Head))((Tail(Cons))(Nil))) end end end end.

