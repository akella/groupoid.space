extends ../../layout.pug

block title
    title OM
    script(src='http://cdn.mathjax.org/mathjax/2.6-latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML')
    script.
         MathJax.Hub.Config({ displayAlign: "left", tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']], processEscapes: true } });

block content
    +header('http://groupoid.space/groupoid.svg', 'Pure Type System', 'OM &mdash; language with universal quntifier and infinity number of universes for typechecking and normalization')
    article.main
        .om
            section
                h1 Definition

                h2#nat Universes
                p.
                    The <b>OM</b> language is a higher-order dependently typed lambda calculus,
                    an extension of Coquand's Calculus of Constructions
                    with the predicative/impredicative hierarchy of indexed universes.
                    This extension is motivated avoiding paradoxes in dependent theory.
                    Also there is no fixpoint axiom needed for the definition
                    of infinity term dependance.
                code.
                    U₀ : U₁ : U₂ : U₃ : …

                    U₀ — propositions
                    U₁ — values and sets       
                    U₂ — types
                    U₃ — sorts
                .semantics
                        figure.
                           \begin{equation}
                            \tag{S}
                            \dfrac
                            {o : Nat}
                            {Type_o}
                            \end{equation}
                h2#axioms Predicative Universes
                p.
                    All terms obey the <b>A</b> ranking inside the sequence of <b>S</b> universes,
                    and the complexity <b>R</b> of the dependent term is equal to a maximum of
                    the term's complexity and its dependency.
                    The universes system is completely described by the following
                    PTS notation (due to Barendregt):
                code.
                    S    (n : nat) = U n
                    A₁ (n m : nat) = U n : U m where m > n — cumulative
                    R₁ (m n : nat) = U m ⟶ U n : U (max m n) — predicative      
                p.
                    Note that predicative universes are incompatible with Church lambda term encoding.
                    You can switch predicative vs impredicative uninverses by typecheker parameter.
                .semantics
                        figure.
                            $$
                            \begin{equation}
                            \tag{A₁}
                            \dfrac
                            {i: Nat,\ \ \ \ j: Nat,\ \ \ \ i < j}
                            {Type_i : Type_{j}}
                            \end{equation}
                            $$
                        figure.
                            $$
                            \begin{equation}
                            \tag{R₁}
                            \dfrac
                            {i : Nat,\ \ \ \ j : Nat}
                            {Type_i \rightarrow Type_{j} : Type_{max(i,j)}}
                            \end{equation}
                            $$

                h2#axioms Impredicative Universes
                p.
                    Propositional contractible bottom space is the only
                    available extension to predicative hierarchy that not leads to inconsistency.
                    However there is another option to have infinite
                    impredicative hierarchy.
                code.
                    A₂   (n : nat) = U n : U (n + 1) — non-cumulative      
                    R₂ (m n : nat) = U m ⟶ U n : U n — impredicative

                .semantics
                        figure.
                            $$
                            \begin{equation}
                            \tag{A₂}
                            \dfrac
                            {i: Nat}
                            {Type_i : Type_{i+1}}
                            \end{equation}
                            $$
                        figure.
                            $$
                            \begin{equation}
                            \tag{R₂}
                            \dfrac
                            {i : Nat,\ \ \ \ j : Nat}
                            {Type_i \rightarrow Type_{j} : Type_{j}}
                            \end{equation}
                            $$

                h2#ast Single Axiom Language
                p.
                    This langauge is called one axiom language (or pure) as eliminator
                    and introduction adjoint functors inferred from type formation rule.
                    The only computation rule of Pi type is called beta-reduction.
                code.
                    ∀ (x: A) → B x : Type                  — formation rule
                    λ (x: A) → b   : B x                   — introduction
                    f a : B [a/x]                          — elimination
                    (λ (x: A) → b) a = b [a/x] : B [a/x]   — equation

                .semantics
                    figure.
                        \begin{equation}
                        \tag{$\Pi$-formation}
                        \dfrac
                        {x:A \vdash B : Type}
                        {\Pi\ (x:A) \rightarrow B : Type}
                        \end{equation}
                    figure.
                        \begin{equation}
                        \tag{$\lambda$-intro}
                        \dfrac
                        {x:A \vdash b : B}
                        {\lambda\ (x:A) \rightarrow b : \Pi\ (x: A) \rightarrow B }
                        \end{equation}
                    br
                    figure.
                        $$
                        \begin{equation}
                        \tag{$App$-elimination}
                        \dfrac
                        {f: (\Pi\ (x:A) \rightarrow B)\ \ \ a: A}
                        {f\ a : B\ [a/x]}
                        \end{equation}
                        $$
                    figure.
                        $$
                        \begin{equation}
                        \tag{$\beta$-computation}
                        \dfrac
                        {x:A \vdash b: B\ \ \ a:A}
                        {(\lambda\ (x:A) \rightarrow b)\ a = b\ [a/x] : B\ [a/x]}
                        \end{equation}
                        $$

                p.
                    This language could be embedded in itself and used
                    as Logical Framework for the Pi type:
                code.
                    Record Pi (A: Type) :=
                           intro: (A → Type) → Type
                           lambda: (B: A → Type) → ∀ (a: A) → B a → intro B
                           app: (B: A → Type) → intro B → ∀ (a: A) → B a
                           app-lam (B: A → Type) (f: ∀ (a: A) → B a): ∀ (a: A) → app (fun f) a ==> f a
                           lam-app (B: A → Type) (p: intro B): fun (λ (a: A) → app p a) ==> p.

                h2#ast Syntax
                p.
                    The terms of OM consist of <b>nat</b> indexed stars, variables, applications,
                    abstractions and universal quantifications. This language is called Calculus
                    of Construction and exists in various syntaxes. OM supports <b>Morte's</b> syntax.
                code.
                    <> = #option
                    I  = #identifier
                    U  = * < #number >
                    OM = U | I | ( OM )  | λ ( I : OM ) → OM      
                         OM OM | OM → OM | ∀ ( I : OM ) → OM
                p.
                    Equivalent tree encoding for parsed terms is following:
                code.
                    Inductive OM := Star: nat → OM
                                  | Var: name → OM
                                  | App: OM → OM → OM
                                  | Lambda: name → OM → OM → OM    
                                  | Arrow: OM → OM → OM
                                  | Pi: name → OM → OM → OM.

                h2#typechecker Typechecker
                p.
                    The typechecker is structural recursive function over OM terms.
                    It lookups variables from the context.
                code.
                    Fixpoint typecheker (t: OM, c: Context): OM :=
                         match t
                         | Pi n 0 i o => Star max (star (type i c))
                                                  (star (type o [(n,norm i)|c]))
                         | Arrow i o  => Star max (star (type i c))
                                                  (star (type o c))
                         | Lambda n 0 i o => let _ = star (type i c) in
                                             let ni = norm i in
                                             Pi n 0 ni (type O [(n,ni)|c])
                         | App f a => match type f c
                                      | Pi n 0 i o => let _ = eq i (type a c)
                                                      in norm (subst o n a)
                                      | _ => error "app"
                         | Var n => match get c n
                                    | Some x => x
                                    | None => error "var"
                         | Star n => Star n + 1

            section
                h1 Passes

                h2#normal Normalized
                p Terms in OM language.
                code.
                    $ om show List/Cons

                    λ (A: *)
                    → λ (Head: A)
                    → λ (Tail:
                        ∀ (List: *)
                    → ∀ (Cons:
                        ∀ (Head: A)
                        → ∀ (Tail: List)
                        → List)
                    → ∀ (Nil: List)
                    → List)
                    → λ (List: *)
                    → λ (Cons:
                        ∀ (Head: A)
                    → ∀ (Tail: List)
                    → List)
                    → λ (Nil: List)
                    → Cons Head (Tail List Cons Nil)

                h2#syntax Extract Language
                p.
                    The untyped lambda language O is the simplest language used in
                    OM to generate backend programs. This O is used as the output of type erasure.
                code.
                    I = #identifier
                    O = I | ( O ) | O O | λ I ⟶ O     
                br.
                code.
                    Inductive O := Var: nat → O
                                 | App: O → O → O
                                 | Lambda: nat → O → O → O.    

                h2#erased Erased
                p.
                    Terms in untyped lambda pure language.
                code.
                    $ om print fst erase a "#List/Cons"
                    ( λ Head
                    → ( λ Tail
                    → ( λ Cons
                    → ( λ Nil
                    → ((Cons Head) ((Tail Cons) Nil))))))
                    ok
                p.
                    Erlang extracted code. For other targets you may want to read
                    <a href='../../lc/extract'> Code Extract</a> notes.
                code.
                    'Cons'() -> fun (Head) -> fun (Tail) -> fun (Cons) -> fun (Nil) ->
                        ((Cons(Head))((Tail(Cons))(Nil))) end end end end.

