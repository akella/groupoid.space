<!DOCTYPE html><html><head><meta charset="utf-8"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="author" content="Maxim Sokhatsky"><meta property="og:title" content="Groupoid Infinity"><meta property="og:image" content="http://groupoid.space/grp.png"><meta property="og:type" content="website"><meta property="fb:app_id" content="118554188236439"><meta property="og:url" content="http://groupoid.space"><meta property="og:description" content="Infinity Language"><link rel="stylesheet" href="http://groupoid.space/main.css"><title>OM</title></head><body class="content"><header class="header"><a href="http://groupoid.space/"><img class="header__logo" src="http://groupoid.space/groupoid.svg"/></a><div class="header__titles"><h1 class="header__title">Single Axiom Language</h1><h4 class="header__subtitle">OM &mdash; language with universal quntifier and infinity number of universes for typechecking and normalization</h4></div></header><article class="main"><div class="om"><section><h1>Definition</h1><h2 id="nat">Pure Type System</h2><p>The <b>OM</b> language is a dependently typed lambda calculus,
an extension of Barendregt' and Coquand Calculus of Constructions
with the predicative hierarchy of indexed universes.
There is no fixpoint axiom needed for the definition of infinity term dependance.</p><code>U₀ : U₁ : U₂ : U₃ : …

U₀ — propositions
U₁ — values and sets       
U₂ — types
U₃ — sorts
</code><h2 id="axioms">Axioms and Inference Rules</h2><p>All terms obey the <b>A</b> ranking inside the sequence of <mark>S</mark> universes,
and the complexity <b>R</b> of the dependent term is equal to a maximum of
the term's complexity and its dependency.
The type system is completely described by the following PTS notation (due to Barendregt):</p><code>S    (n : nat) = U n
A₁ (n m : nat) = U n : U m where m > n — cumulative
R₁ (m n : nat) = U m ⟶ U n : U (max m n) — predicative      
</code><h2 id="axioms">Impredicative Propositional Universe</h2><p>Propositional contractible bottom space is impredicative by term dependance.</p><code>A₂   (n : nat) = U n : U (n + 1) — non-cumulative      
R₂ (m n : nat) = U m ⟶ U n : U n — impredicative
</code><h2 id="ast">Type System a la Martin-Löf</h2><p>This langauge is called one axiom language as it reduction
rule is inferred from type formation axiom along with eliminator
and introduction adjoint functors.</p><code>∀ (x: A) → B x : Type            — formation rule
λ (x: A) → b   : B x             — introduction
f a : B x                        — elimination
(λ (a: A) → b) a = b [p/a] : B x — equation</code><p>This language could be embedded in itself and used as Logical Framework.</p><code>Record Pi (A: Type) :=
       intro: (A → Type) → Type
       lambda: (B: A → Type) → ∀ (a: A) → B a → intro B
       app: (B: A → Type) → intro B → ∀ (a: A) → B a
       app-lam (B: A → Type) (f: ∀ (a: A) → B a): ∀ (a: A) → app (fun f) a ==> f a
       lam-app (B: A → Type) (p: intro B): fun (λ (a: A) → app p a) ==> p.
</code><h2 id="ast">AST</h2><p>The terms of OM consist of <b>nat</b> indexed stars, variables, applications,
abstractions and universal quantifications. This language is called Calculus
of Construction and exists in various syntaxes. OM supports <b>Morte's</b> syntax.</p><code><> = #option
I  = #identifier
U  = * < #number >
OM = U | I | ( OM )  | λ ( I : OM ) → OM      
     OM OM | OM → OM | ∀ ( I : OM ) → OM</code><p>Equivalent tree encoding for parsed terms is following:</p><code>Inductive OM := Star: nat → OM)
              | Var: name → OM)
              | App: OM → OM → OM)
              | Lambda: name → OM → OM → OM)    
              | Arrow: OM → OM → OM)
              | Pi: name → OM → OM → OM).
</code><h2 id="typechecker">Typechecker</h2><code>type (Star n)         D : Star n + 1

type (Var n)          D : let _ = isVar n D
                          in nth (i + 1) (all n D)

type (Arrow i o)      D : Star max (star (type i D))
                                   (star (type o D))

type (Pi n 0 i o)     D : Star max (star (type i D))
                                   (star (type o [(n norm i)|D]))

type (Lambda n 0 i o) D : let _ = star (type i D) in
                          let ni = norm i in
                          Pi n 0 ni (type O [(n ni)|D])

type (App f a)        D : let t = type f D in
                          let _ = isFun t in
                          match t
                           | Pi n 0 i o => let _ = eq i (type a D)
                                           in norm (subst o n a)
</code></section><section><h1>Passes</h1><h2 id="normal">Normalized</h2><p>Terms in OM language.</p><code>$ om show List/Cons

λ (A: *)
→ λ (Head: A)
→ λ (Tail:
    ∀ (List: *)
→ ∀ (Cons:
    ∀ (Head: A)
    → ∀ (Tail: List)
    → List)
→ ∀ (Nil: List)
→ List)
→ λ (List: *)
→ λ (Cons:
    ∀ (Head: A)
→ ∀ (Tail: List)
→ List)
→ λ (Nil: List)
→ Cons Head (Tail List Cons Nil)
</code><h2 id="syntax">Extract Language</h2><p>The untyped lambda language O is the simplest language used in
OM to generate backend programs. This O is used as the output of type erasure.</p><code>I = #identifier
O = I | ( O ) | O O | λ I ⟶ O     </code><br><code>Inductive O := Var: nat → O)
             | App: O → O → O)
             | Lambda: nat → O → O → O).    
</code><h2 id="erased">Erased</h2><p>Terms in untyped lambda pure language.</p><code>$ om print fst erase a "#List/Cons"
( λ Head
→ ( λ Tail
→ ( λ Cons
→ ( λ Nil
→ ((Cons Head) ((Tail Cons) Nil))))))
ok</code><p>Erlang extracted code. For other targets you may want to read
<a href='../../lc/extract'> Code Extract</a> notes.</p><code>'Cons'() -> fun (Head) -> fun (Tail) -> fun (Cons) -> fun (Nil) ->
    ((Cons(Head))((Tail(Cons))(Nil))) end end end end.</code></section></div></article><footer class="footer"><img class="footer__logo" src="http://groupoid.space/stamp.svg"><span class="footer__copy">2016&mdash;2017 &copy; Groupoid Infinity</span></footer><script src="http://groupoid.space/bundle.js"></script><script src="http://groupoid.space/highlight.js"></script></body></html>