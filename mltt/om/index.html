<!DOCTYPE html><html><head><meta charset="utf-8"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="author" content="Maxim Sokhatsky"><meta property="og:title" content="Groupoid Infinity"><meta property="og:image" content="http://groupoid.space/grp.png"><meta property="og:type" content="website"><meta property="fb:app_id" content="118554188236439"><meta property="og:url" content="http://groupoid.space"><meta property="og:description" content="Infinity Language"><link rel="stylesheet" href="http://groupoid.space/main.css"><title>OM</title><script src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.6.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>MathJax.Hub.Config({ displayAlign: "left", tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']], processEscapes: true } });
</script></head><body class="content"><header class="header"><a href="http://groupoid.space/"><img class="header__logo" src="//groupoid.space/groupoid.svg"/></a><div class="header__titles"><h1 class="header__title">Pure Type System</h1><h4 class="header__subtitle">OM &mdash; language with universal quntifier and infinity number of universes for typechecking and normalization</h4></div></header><article class="main"><div class="om"><section><h1>Definition</h1><h2 id="nat">Universes</h2><p>The <b>OM</b> language is a higher-order dependently typed lambda calculus,
an extension of Coquand's Calculus of Constructions
with the predicative/impredicative hierarchy of indexed universes.
This extension is motivated avoiding paradoxes in dependent theory.
Also there is no fixpoint axiom needed for the definition
of infinity term dependance.</p><code>U₀ : U₁ : U₂ : U₃ : …

U₀ — propositions
U₁ — values and sets       
U₂ — types
U₃ — sorts</code><div class="semantics"><figure>\begin{equation}
 \tag{S}
 \dfrac
 {o : Nat}
 {Type_o}
 \end{equation}</figure></div><h2 id="axioms">Predicative Universes</h2><p>All terms obey the <b>A</b> ranking inside the sequence of <b>S</b> universes,
and the complexity <b>R</b> of the dependent term is equal to a maximum of
the term's complexity and its dependency.
The universes system is completely described by the following
PTS notation (due to Barendregt):</p><code>S    (n : nat) = U n
A₁ (n m : nat) = U n : U m where m > n — cumulative
R₁ (m n : nat) = U m ⟶ U n : U (max m n) — predicative      </code><p>Note that predicative universes are incompatible with Church lambda term encoding.
You can switch predicative vs impredicative uninverses by typecheker parameter.</p><div class="semantics"><figure>$$
\begin{equation}
\tag{A₁}
\dfrac
{i: Nat,\ \ \ \ j: Nat,\ \ \ \ i < j}
{Type_i : Type_{j}}
\end{equation}
$$</figure><figure>$$
\begin{equation}
\tag{R₁}
\dfrac
{i : Nat,\ \ \ \ j : Nat}
{Type_i \rightarrow Type_{j} : Type_{max(i,j)}}
\end{equation}
$$
</figure></div><h2 id="axioms">Impredicative Universes</h2><p>Propositional contractible bottom space is the only
available extension to predicative hierarchy that not leads to inconsistency.
However there is another option to have infinite
impredicative hierarchy.</p><code>A₂   (n : nat) = U n : U (n + 1) — non-cumulative      
R₂ (m n : nat) = U m ⟶ U n : U n — impredicative
</code><div class="semantics"><figure>$$
\begin{equation}
\tag{A₂}
\dfrac
{i: Nat}
{Type_i : Type_{i+1}}
\end{equation}
$$</figure><figure>$$
\begin{equation}
\tag{R₂}
\dfrac
{i : Nat,\ \ \ \ j : Nat}
{Type_i \rightarrow Type_{j} : Type_{j}}
\end{equation}
$$
</figure></div><h2 id="ast">Single Axiom Language</h2><p>This langauge is called one axiom language (or pure) as eliminator
and introduction adjoint functors inferred from type formation rule.
The only computation rule of Pi type is called beta-reduction.</p><code>∀ (x: A) → B x : Type                  — formation rule
λ (x: A) → b   : B x                   — introduction
f a : B [a/x]                          — elimination
(λ (x: A) → b) a = b [a/x] : B [a/x]   — equation
</code><div class="semantics"><figure>\begin{equation}
\tag{$\Pi$-formation}
\dfrac
{x:A \vdash B : Type}
{\Pi\ (x:A) \rightarrow B : Type}
\end{equation}</figure><figure>\begin{equation}
\tag{$\lambda$-intro}
\dfrac
{x:A \vdash b : B}
{\lambda\ (x:A) \rightarrow b : \Pi\ (x: A) \rightarrow B }
\end{equation}</figure><br><figure>$$
\begin{equation}
\tag{$App$-elimination}
\dfrac
{f: (\Pi\ (x:A) \rightarrow B)\ \ \ a: A}
{f\ a : B\ [a/x]}
\end{equation}
$$</figure><figure>$$
\begin{equation}
\tag{$\beta$-computation}
\dfrac
{x:A \vdash b: B\ \ \ a:A}
{(\lambda\ (x:A) \rightarrow b)\ a = b\ [a/x] : B\ [a/x]}
\end{equation}
$$
</figure></div><p>This language could be embedded in itself and used
as Logical Framework for the Pi type:</p><code>Record Pi (A: Type) :=
       intro: (A → Type) → Type
       lambda: (B: A → Type) → ∀ (a: A) → B a → intro B
       app: (B: A → Type) → intro B → ∀ (a: A) → B a
       app-lam (B: A → Type) (f: ∀ (a: A) → B a): ∀ (a: A) → app (fun f) a ==> f a
       lam-app (B: A → Type) (p: intro B): fun (λ (a: A) → app p a) ==> p.
</code><h2 id="ast">Syntax</h2><p>The terms of OM consist of <b>nat</b> indexed stars, variables, applications,
abstractions and universal quantifications. This language is called Calculus
of Construction and exists in various syntaxes. OM supports <b>Morte's</b> syntax.</p><code><> = #option
I  = #identifier
U  = * < #number >
OM = U | I | ( OM )  | λ ( I : OM ) → OM      
     OM OM | OM → OM | ∀ ( I : OM ) → OM</code><p>Equivalent tree encoding for parsed terms is following:</p><code>Inductive OM := Star: nat → OM
              | Var: name → OM
              | App: OM → OM → OM
              | Lambda: name → OM → OM → OM    
              | Arrow: OM → OM → OM
              | Pi: name → OM → OM → OM.
</code><h2 id="typechecker">Typechecker</h2><p>The typechecker is structural recursive function over OM terms.
It lookups variables from the context.</p><code>Definition star(t: OM): nat :=
     match t
     | Star n => n
     | _ => error "star"

Fixpoint type (t: OM, c: Context): OM :=
     match t
     | Pi n 0 i o => Star max (star (type i c))
                              (star (type o [(n,norm i)|c]))
     | Arrow i o  => Star max (star (type i c))
                              (star (type o c))
     | Lambda n 0 i o => let _ = star (type i c) in
                         let ni = norm i in
                         Pi n 0 ni (type O [(n,ni)|c])
     | App f a => match type f c
                  | Pi n 0 i o => let _ = eq i (type a c)
                                  in norm (subst o n a)
                  | _ => error "app"
     | Var n => match get c n
                | Some x => x
                | None => error "var"
     | Star n => Star n + 1
</code></section><section><h1>Passes</h1><h2 id="normal">Normalized</h2><p>Terms in OM language.</p><code>$ om show List/Cons

λ (A: *)
→ λ (Head: A)
→ λ (Tail:
    ∀ (List: *)
→ ∀ (Cons:
    ∀ (Head: A)
    → ∀ (Tail: List)
    → List)
→ ∀ (Nil: List)
→ List)
→ λ (List: *)
→ λ (Cons:
    ∀ (Head: A)
→ ∀ (Tail: List)
→ List)
→ λ (Nil: List)
→ Cons Head (Tail List Cons Nil)
</code><h2 id="syntax">Extract Language</h2><p>The untyped lambda language O is the simplest language used in
OM to generate backend programs. This O is used as the output of type erasure.</p><code>I = #identifier
O = I | ( O ) | O O | λ I ⟶ O     </code><br><code>Inductive O := Var: nat → O
             | App: O → O → O
             | Lambda: nat → O → O → O.    
</code><h2 id="erased">Erased</h2><p>Terms in untyped lambda pure language.</p><code>$ om print fst erase a "#List/Cons"
( λ Head
→ ( λ Tail
→ ( λ Cons
→ ( λ Nil
→ ((Cons Head) ((Tail Cons) Nil))))))
ok</code><p>Erlang extracted code. For other targets you may want to read
<a href='../../lc/extract'> Code Extract</a> notes.</p><code>'Cons'() -> fun (Head) -> fun (Tail) -> fun (Cons) -> fun (Nil) ->
    ((Cons(Head))((Tail(Cons))(Nil))) end end end end.</code></section></div></article><footer class="footer"><img class="footer__logo" src="http://groupoid.space/stamp.svg"><span class="footer__copy">2016&mdash;2017 &copy; Groupoid Infinity</span></footer><script src="http://groupoid.space/bundle.js"></script><script src="http://groupoid.space/highlight.js"></script></body></html>