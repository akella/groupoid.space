extends ../../layout.pug

block title
    title INDUCTIVE
    script(src='//cdnjs.cloudflare.com/ajax/libs/mathjax/2.6.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML')
    script.
        MathJax.Hub.Config({ displayAlign: "left", tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']], processEscapes: true } });

block content
    +header('../../groupoid.svg', 'Path Isomorphism', 'Comparing two Zeros')
    article.main
        .om
            section
                h1 Article
        aside Denis Stoyanov
            Maxim Sokhatsky
            time DATE: 19 OCT 2017
        .om
            section
                h2 Abstract
                p.
                    This work shows how to encode inductive types using recursion schemes.
                    Unlike Church-Boem-Berarducci encoding, that can encode inductive types
                    without fixpoint, recursion shcemes require the fixpoint contructor
                    in the typechecker core in order to express this encoding.
                p.
                h2 Prelude
                p.
                    We will use <mark>cubical</mark> typechecker for modeling. You may want
                    to try this in Agda, Idris, Coq or any MLTT prover. First we need to
                    set up inductive type typle, because the <b>para</b> is unexpressible
                    with Sigma pair type.
                code.
                    data tuple (A B: U) = pair (a: A) (b: B)
                    fst (A B: U): tuple A B -> A = split pair a b -> a
                    snd (A B: U): tuple A B -> B = split pair a b -> b
                p.
                    Then assume we have fmap defined somewhere else.
                code.
                    fmap (A B: U) (F: U -> U): (A -> B) -> F A -> F B = undefined

                h2 Fixpoint
                p.
                    The core fixpoint reflection type is parametrized by functor
                    and has only one contructor with value of this functor applied to fixpoint itself.
                    We also need functions for projecting and embedding valued to/from
                    fixpoint functiorial stream.
                code.
                    data fix (F: U -> U) = Fix (point: F (fix F))
                    unfix (F: U -> U): fix F -> F (fix F) = split Fix f -> f
                    embed (F: U -> U): F (fix F) -> fix F = \(x: F (fix F)) -> Fix x

                h2 Catamorphism
                p.
                    Catamorphism is known as generalized version of fold.
                code.
                    cata (A: U) (F: U -> U) (alg: F A -> A) (f: fix F): A
                        = alg (fmap (fix F) A F (cata A F alg) (unfix F f))
                h2 Iniductive
                p.
                    Lets rewrite fix data type as a structure:
                code.
                    ind (F: U -> U) (A: U): U
                        = (in_: F (fix F) -> fix F)
                        * (unfix_: fix F -> F (fix F))
                        * (fold_: (F A -> A) -> fix F -> A)
                        * Unit
                p.
                    Then instance of this type class would be:
                code.
                    inductive (F: U -> U) (A: U): ind F A
                        = (embed F,unfix F,cata A F,tt)

                h2 Inductive List Nat
                p.
                    Here is example of inductive encoding of list nat:
                code.
                    > inductive list nat
                pre.
                    EVAL: ((\(x : F (fix F)) -> Fix x) (F = (\(A : U) -> list)),
                    (unfix (\(A : U) -> list),((\(alg : Pi \(_ : F A) -> A) ->
                    \(f : fix F) -> alg (fmap (fix F) A F (cata A F alg)
                    (unfix F f))) (A = nat, F = (\(A : U) -> list)),tt)))

                h2 Appendix

                h3 Anamorphism
                code.
                    ana  (A: U) (F: U -> U) (coalg: A -> F A) (a: A): fix F
                        = Fix (fmap A (fix F) F (ana A F coalg) (coalg a))

                h3 Hylomorphism
                code.
                    hylo (A B: U) (F: U -> U)
                         (alg: F B -> B) (coalg: A -> F A) (a: A): B
                        = alg (fmap A B F (hylo A B F alg coalg) (coalg a))

                h3 Paramorphism
                code.
                    para (A: U) (F: U -> U)
                         (psi: F (tuple (fix F) A) -> A) (f: fix F): A
                        = psi (fmap (fix F) (tuple (fix F) A) F (\(m: fix F)
                        -> pair m (para A F psi m)) (unfix F f))
