<html>
<head>
    <meta charset="utf-8" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="description" content="" />
    <meta name="author" content="Maxim Sokhatsky" />
    <title>INTRO</title>
    <link rel="stylesheet" href="5HT.css" />
</head>
<body>
<div class=menu>
<a href="index.html">groupoid.co</a><font color=silver>/intro</font>
</div>
<hr>

<div class=app>

<div class=block style="width:230px;height:550px;">
        <img src="Groupoid.svg" height=200>
</div>

<div class=block style="width:700px">
<center><h1>Intro</h1>
        <h5>Canvas of Computable Functions Theories and Provers</center>

<center><h2><a name="fpga">LISP</a></h2></center>

<p>Untyped lambda calculus was discovered as an inner language of the space
at origin (Curry, Church, 1932). This language was manifested as LISP (McCarthy, 1958)
that was built upon: cons, nil, eq, atom, car, cdr, lambda, apply and id.
It was parts of higher inductive types lately known as inductive type constructors.
Still untyped lambda calculus is used as an extraction target for many
provers (Idris, F*), and also manifests in different domain languages (JavaScript, Erlang).</p>

<center><h2><a name="fpga">ML/LCF</a></h2></center>

<p>Further teardown of inner space language was ML language, founded merely on algebraic
datatypes and algebra on higher terms rather than categorical semantic. Lately it
was fixed with categorical methods in CPL (Hagino, 1987) and Charity (Cockett, 1992).
Milner, assisted by Morris and Newey designed Meta Language for the purpose of builing LCF
in early 70-s. LCF was a predecessor family of automated math provers: HOL88,
HOL90, HOL98 and HOL/Isabelle which is now built using Poly/ML.</p>

<center><h2><a name="other">Fully Automated Provers</a></h2></center>

<p>In that period during 80-90s other automated math systems were appeared:
AUTOMATH (de Bruijn, 1967), Mizar (Trybulec, 1989), PVS (Owre, Rushby, Shankar, 1995),
ACL2 (Boyer, Kaufmann, Moore, 1996) and Otter (McCune, 1996).</p>

<center><h2><a name="mltt">MLTT</a></h2></center>

<p>Contemporary provers (built upon Martin-LÃ¶f Type Theory, 1972)
like Agda, Coq, Lean, F*, Idris are based on Barendregt
and Coquand' CoC with different flavours of inifinity universe hierarchies
and Calculus of Inductive Constructions. Some of them are automated and some
are trying to be and general purpose programming languages with proving facilities.</p>

<center><h2><a name="fpga">OM/EXE</a></h2></center>

<p><b>No Fixpoint and Induction in Core</b>. We came up with pure CoC core having
predicative and impredicative universe hierachies and macro extensions. Other MLTT
cores has additional axioms like Fixpoint and Induction (and even more) &mdash;
something we strive to escape, because it leads to clean and understandable core.
No, we don't have Fixpoint, and yes, we implemented Induction principle in pure CoC.</p>

<p><b>Extensible Language Design</b>. Encoding of inductive types is based on categorical
semantic of compilation to CoC. All other syntax constructions are inductive
definitions, plugged into the stream parser. AST of the CoC language is also
defined in terms of inductive constructions and thus allowed in the macros.
The language of polynomial functors (data and record) and core language of
the process calculus (spawn, receive and send) are just macrosystem over CoC language,
its syntax extensions.</p>

<p><b>Changable Encodings</b>. In pure CoC we have only arrows, so all inductive type encodings would
be Church-encoding variations. Most extended nowadays is Church-Boehm-Berrarducci encoding,
which dedicated to inductive types. Another well known are Scott (lazyness) and
Parigot (lazyness and constant-time iterators) encodings.</p>

<p><b>Proved Categorical Semantic</b>. There was modeled a math model of encoding,
which calculates (co)limits in a cathegory of (co)algebras built with given set of (de)constructors.
We call such encoding in honour of Lambek lemma that leeds us to the
equality of (co)initial object and (co)limit in the categories of (co)algebras.
Such encoding works with dependent types and its consistency is proved in Lean model.</p>

<br>

<center style="margin-top: 120px;margin-bottom:60px;"><img style="margin-bottom:-20px;" src="Stamp.svg" width=50>2016 &copy; Groupoid Infinity, Inc.</center>


</body>
</html>
